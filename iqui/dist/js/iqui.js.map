{
  "version": 3,
  "file": "iqui.js",
  "sources": [
    "src/iqui.js",
    "src/scripts/autosize.js",
    "src/scripts/datepicker/date-formatter.js",
    "src/scripts/datepicker/date-parser.js",
    "src/scripts/datepicker/datepicker.js",
    "src/scripts/datepicker/datetimepicker.js",
    "src/scripts/datepicker/dimensions.js",
    "src/scripts/datepicker/timepicker.js",
    "src/scripts/datepicker/tooltip.js",
    "src/scripts/dialog.js",
    "src/scripts/loadingbar.js",
    "src/scripts/multiselect.js",
    "src/scripts/ng-table.js",
    "src/scripts/organisation.js",
    "src/scripts/scrollbar.js",
    "src/scripts/search.js",
    "src/scripts/select.js",
    "src/scripts/sidebar.js",
    "src/scripts/toaster.js",
    "src/scripts/topsearch.js",
    "src/scripts/translate.js",
    "src/scripts/utils.js",
    "build/template.html.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACr0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACngCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourceRoot": "../../",
  "sourcesContent": [
    "(function () {\n\n    'use strict';\n\n    var _config = {\n        version: '0.2.4'\n    };\n\n    angular\n        .module('iq.ui', [\n            'ui.router',\n            'ui.bootstrap',\n            'ui.datetimepicker',\n            'ui.utils',\n            'ui.dialog',\n            'ui.loadingbar',\n            'ui.multiselect',\n            'ui.toaster',\n            'ui.select',\n            'ui.sidebar',\n            'ui.scrollbar',\n            'ui.search',\n            'ui.translate',\n            'ui.organisation',\n            'ui.templates'\n        ])\n\n        .value('$commonVersion', _config.version)\n\n        .run(function ($commonVersion, $log) {\n            $log.info('iQUI Framework ', $commonVersion);\n        });\n}());\n\n",
    "/*!\n Autosize 1.18.17\n license: MIT\n http://www.jacklmoore.com/autosize\n */\n\n/*\n TODO Refactor as Angular directives and services\n */\n\n(function ($) {\n    var\n        defaults = {\n            className: 'autosizejs',\n            id: 'autosizejs',\n            append: '\\n',\n            callback: false,\n            resizeDelay: 10,\n            placeholder: true\n        };\n    var copy = '<textarea tabindex=\"-1\" style=\"position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;\"/>';\n    var typographyStyles = [\n        'fontFamily',\n        'fontSize',\n        'fontWeight',\n        'fontStyle',\n        'letterSpacing',\n        'textTransform',\n        'wordSpacing',\n        'textIndent',\n        'whiteSpace'\n    ];\n    var mirrored;\n    var mirror = $(copy).data('autosize', true)[0];\n\n    // test that line-height can be accurately copied.\n    mirror.style.lineHeight = '99px';\n    if ($(mirror).css('lineHeight') === '99px') {\n        typographyStyles.push('lineHeight');\n    }\n    mirror.style.lineHeight = '';\n\n    $.fn.autosize = function (options) {\n        if (!this.length) {\n            return this;\n        }\n\n        options = $.extend({}, defaults, options || {});\n\n        if (mirror.parentNode !== document.body) {\n            $(document.body).append(mirror);\n        }\n\n        return this.each(function () {\n            var\n                ta = this,\n                $ta = $(ta),\n                maxHeight,\n                minHeight,\n                boxOffset = 0,\n                callback = $.isFunction(options.callback),\n                originalStyles = {\n                    height: ta.style.height,\n                    overflow: ta.style.overflow,\n                    overflowY: ta.style.overflowY,\n                    wordWrap: ta.style.wordWrap,\n                    resize: ta.style.resize\n                },\n                timeout,\n                width = $ta.width(),\n                taResize = $ta.css('resize');\n\n            if ($ta.data('autosize')) {\n                // exit if autosize has already been applied, or if the textarea is the mirror element.\n                return;\n            }\n            $ta.data('autosize', true);\n\n            if ($ta.css('box-sizing') === 'border-box' || $ta.css('-moz-box-sizing') === 'border-box' || $ta.css('-webkit-box-sizing') === 'border-box') {\n                boxOffset = ($ta.outerHeight() - $ta.height()) - 11;\n            }\n\n            // IE8 and lower return 'auto', which parses to NaN, if no min-height is set.\n            minHeight = Math.max(parseFloat($ta.css('minHeight')) - boxOffset || 0, $ta.height());\n\n            $ta.css({\n                overflow: 'hidden',\n                overflowY: 'hidden',\n                wordWrap: 'break-word' // horizontal overflow is hidden, so break-word is necessary for handling words longer than the textarea width\n            });\n\n            if (taResize === 'vertical') {\n                $ta.css('resize', 'none');\n            } else if (taResize === 'both') {\n                $ta.css('resize', 'horizontal');\n            }\n\n            // getComputedStyle is preferred here because it preserves sub-pixel values, while jQuery's .width() rounds to an integer.\n            function setWidth() {\n                var width;\n                var style = window.getComputedStyle ? window.getComputedStyle(ta, null) : null;\n\n                if (style) {\n                    width = parseFloat(style.width);\n                    if (style.boxSizing === 'border-box' || style.webkitBoxSizing === 'border-box' || style.mozBoxSizing === 'border-box') {\n                        $.each(['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'], function(i, val) {\n                            width -= parseFloat(style[val]);\n                        });\n                    }\n                } else {\n                    width = $ta.width();\n                }\n\n                mirror.style.width = Math.max(width, 0) + 'px';\n            }\n\n            function initMirror() {\n                var styles = {};\n\n                mirrored = ta;\n                mirror.className = options.className;\n                mirror.id = options.id;\n                maxHeight = parseFloat($ta.css('maxHeight'));\n\n                // mirror is a duplicate textarea located off-screen that\n                // is automatically updated to contain the same text as the\n                // original textarea.  mirror always has a height of 0.\n                // This gives a cross-browser supported way getting the actual\n                // height of the text, through the scrollTop property.\n                $.each(typographyStyles, function(i, val) {\n                    styles[val] = $ta.css(val);\n                });\n\n                $(mirror).css(styles).attr('wrap', $ta.attr('wrap'));\n\n                setWidth();\n\n                // Chrome-specific fix:\n                // When the textarea y-overflow is hidden, Chrome doesn't reflow the text to account for the space\n                // made available by removing the scrollbar. This workaround triggers the reflow for Chrome.\n                if (window.chrome) {\n                    var width = ta.style.width;\n                    ta.style.width = '0px';\n                    var ignore = ta.offsetWidth;\n                    ta.style.width = width;\n                }\n            }\n\n            // Using mainly bare JS in this function because it is going\n            // to fire very often while typing, and needs to very efficient.\n            function adjust() {\n                var height, originalHeight;\n\n                if (mirrored !== ta) {\n                    initMirror();\n                } else {\n                    setWidth();\n                }\n\n                if (!ta.value && options.placeholder) {\n                    // If the textarea is empty, copy the placeholder text into\n                    // the mirror control and use that for sizing so that we\n                    // don't end up with placeholder getting trimmed.\n                    mirror.value = ($ta.attr(\"placeholder\") || '');\n                } else {\n                    mirror.value = ta.value;\n                }\n\n                mirror.value += options.append || '';\n                mirror.style.overflowY = ta.style.overflowY;\n                originalHeight = parseFloat(ta.style.height) || 0;\n\n                // Setting scrollTop to zero is needed in IE8 and lower for the next step to be accurately applied\n                mirror.scrollTop = 0;\n\n                mirror.scrollTop = 9e4;\n\n                // Using scrollTop rather than scrollHeight because scrollHeight is non-standard and includes padding.\n                height = mirror.scrollTop;\n\n                if (maxHeight && height > maxHeight) {\n                    ta.style.overflowY = 'scroll';\n                    height = maxHeight;\n                } else {\n                    ta.style.overflowY = 'hidden';\n                    if (height < minHeight) {\n                        height = minHeight;\n                    }\n                }\n\n                height += boxOffset;\n\n                if (Math.abs(originalHeight - height) > 1 / 100) {\n                    ta.style.height = height + 'px';\n\n                    // Trigger a repaint for IE8 for when ta is nested 2 or more levels inside an inline-block\n                    mirror.className = mirror.className;\n\n                    if (callback) {\n                        options.callback.call(ta, ta);\n                    }\n                    $ta.trigger('autosize.resized');\n                }\n            }\n\n            function resize () {\n                clearTimeout(timeout);\n                timeout = setTimeout(function() {\n                    var newWidth = $ta.width();\n\n                    if (newWidth !== width) {\n                        width = newWidth;\n                        adjust();\n                    }\n                }, parseInt(options.resizeDelay, 10));\n            }\n\n            if ('onpropertychange' in ta) {\n                if ('oninput' in ta) {\n                    // Detects IE9.  IE9 does not fire onpropertychange or oninput for deletions,\n                    // so binding to onkeyup to catch most of those occasions.  There is no way that I\n                    // know of to detect something like 'cut' in IE9.\n                    $ta.on('input.autosize keyup.autosize', adjust);\n                } else {\n                    // IE7 / IE8\n                    $ta.on('propertychange.autosize', function() {\n                        if (event.propertyName === 'value') {\n                            adjust();\n                        }\n                    });\n                }\n            } else {\n                // Modern Browsers\n                $ta.on('input.autosize', adjust);\n            }\n\n            // Set options.resizeDelay to false if using fixed-width textarea elements.\n            // Uses a timeout and width check to reduce the amount of times adjust needs to be called after window resize.\n\n            if (options.resizeDelay !== false) {\n                $(window).on('resize.autosize', resize);\n            }\n\n            // Event for manual triggering if needed.\n            // Should only be needed when the value of the textarea is changed through JavaScript rather than user input.\n            $ta.on('autosize.resize', adjust);\n\n            // Event for manual triggering that also forces the styles to update as well.\n            // Should only be needed if one of typography styles of the textarea change, and the textarea is already the target of the adjust method.\n            $ta.on('autosize.resizeIncludeStyle', function() {\n                mirrored = null;\n                adjust();\n            });\n\n            $ta.on('autosize.destroy', function() {\n                mirrored = null;\n                clearTimeout(timeout);\n                $(window).off('resize', resize);\n                $ta\n                    .off('autosize')\n                    .off('.autosize')\n                    .css(originalStyles)\n                    .removeData('autosize');\n            });\n\n            // Call adjust in case the textarea already contains text.\n            adjust();\n        });\n    };\n}(jQuery || $)); // jQuery or jQuery-like library, such as Zepto\n",
    "'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n    .service('$dateFormatter', function ($locale, dateFilter) {\n\n        // The unused `lang` arguments are on purpose. The default implementation does not\n        // use them and it always uses the locale loaded into the `$locale` service.\n        // Custom implementations might use it, thus allowing different directives to\n        // have different languages.\n\n        this.getDefaultLocale = function () {\n            return $locale.id;\n        };\n\n        // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n        // Return either the corresponding date format or the given date format.\n        this.getDatetimeFormat = function (format, lang) {\n            return $locale.DATETIME_FORMATS[format] || format;\n        };\n\n        this.weekdaysShort = function (lang) {\n            return $locale.DATETIME_FORMATS.SHORTDAY;\n        };\n\n        function splitTimeFormat(format) {\n            return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n        }\n\n        // h:mm a => h\n        this.hoursFormat = function (timeFormat) {\n            return splitTimeFormat(timeFormat)[0];\n        };\n\n        // h:mm a => mm\n        this.minutesFormat = function (timeFormat) {\n            return splitTimeFormat(timeFormat)[2];\n        };\n\n        // h:mm:ss a => ss\n        this.secondsFormat = function (timeFormat) {\n            return splitTimeFormat(timeFormat)[4];\n        };\n\n        // h:mm a => :\n        this.timeSeparator = function (timeFormat) {\n            return splitTimeFormat(timeFormat)[1];\n        };\n\n        // h:mm:ss a => true, h:mm a => false\n        this.showSeconds = function (timeFormat) {\n            return !!splitTimeFormat(timeFormat)[4];\n        };\n\n        // h:mm a => true, H.mm => false\n        this.showAM = function (timeFormat) {\n            return !!splitTimeFormat(timeFormat)[5];\n        };\n\n        this.formatDate = function (date, format, lang, timezone) {\n            return dateFilter(date, format, timezone);\n        };\n\n    });\n",
    "'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n    .provider('$dateParser', function ($localeProvider) {\n\n        // define a custom ParseDate object to use instead of native Date\n        // to avoid date values wrapping when setting date component values\n        function ParseDate() {\n            this.year = 1970;\n            this.month = 0;\n            this.day = 1;\n            this.hours = 0;\n            this.minutes = 0;\n            this.seconds = 0;\n            this.milliseconds = 0;\n        }\n\n        ParseDate.prototype.setMilliseconds = function (value) {\n            this.milliseconds = value;\n        };\n        ParseDate.prototype.setSeconds = function (value) {\n            this.seconds = value;\n        };\n        ParseDate.prototype.setMinutes = function (value) {\n            this.minutes = value;\n        };\n        ParseDate.prototype.setHours = function (value) {\n            this.hours = value;\n        };\n        ParseDate.prototype.getHours = function () {\n            return this.hours;\n        };\n        ParseDate.prototype.setDate = function (value) {\n            this.day = value;\n        };\n        ParseDate.prototype.setMonth = function (value) {\n            this.month = value;\n        };\n        ParseDate.prototype.setFullYear = function (value) {\n            this.year = value;\n        };\n        ParseDate.prototype.fromDate = function (value) {\n            this.year = value.getFullYear();\n            this.month = value.getMonth();\n            this.day = value.getDate();\n            this.hours = value.getHours();\n            this.minutes = value.getMinutes();\n            this.seconds = value.getSeconds();\n            this.milliseconds = value.getMilliseconds();\n            return this;\n        };\n\n        ParseDate.prototype.toDate = function () {\n            return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n        };\n\n        var proto = ParseDate.prototype;\n\n        function noop() {\n        }\n\n        function isNumeric(n) {\n            return !isNaN(parseFloat(n)) && isFinite(n);\n        }\n\n        function indexOfCaseInsensitive(array, value) {\n            var len = array.length, str = value.toString().toLowerCase();\n            for (var i = 0; i < len; i++) {\n                if (array[i].toLowerCase() === str) {\n                    return i;\n                }\n            }\n            return -1; // Return -1 per the \"Array.indexOf()\" method.\n        }\n\n        var defaults = this.defaults = {\n            format: 'shortDate',\n            strict: false\n        };\n\n        this.$get = function ($locale, dateFilter) {\n\n            var DateParserFactory = function (config) {\n\n                var options = angular.extend({}, defaults, config);\n\n                var $dateParser = {};\n\n                var regExpMap = {\n                    'sss': '[0-9]{3}',\n                    'ss': '[0-5][0-9]',\n                    's': options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n                    'mm': '[0-5][0-9]',\n                    'm': options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n                    'HH': '[01][0-9]|2[0-3]',\n                    'H': options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n                    'hh': '[0][1-9]|[1][012]',\n                    'h': options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n                    'a': 'AM|PM',\n                    'EEEE': $locale.DATETIME_FORMATS.DAY.join('|'),\n                    'EEE': $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n                    'dd': '0[1-9]|[12][0-9]|3[01]',\n                    'd': options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n                    'MMMM': $locale.DATETIME_FORMATS.MONTH.join('|'),\n                    'MMM': $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n                    'MM': '0[1-9]|1[012]',\n                    'M': options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n                    'yyyy': '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n                    'yy': '[0-9]{2}',\n                    'y': options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n                };\n\n                var setFnMap = {\n                    'sss': proto.setMilliseconds,\n                    'ss': proto.setSeconds,\n                    's': proto.setSeconds,\n                    'mm': proto.setMinutes,\n                    'm': proto.setMinutes,\n                    'HH': proto.setHours,\n                    'H': proto.setHours,\n                    'hh': proto.setHours,\n                    'h': proto.setHours,\n                    'EEEE': noop,\n                    'EEE': noop,\n                    'dd': proto.setDate,\n                    'd': proto.setDate,\n                    'a': function (value) {\n                        var hours = this.getHours() % 12;\n                        return this.setHours(value.match(/pm/i) ? hours + 12 : hours);\n                    },\n                    'MMMM': function (value) {\n                        return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value));\n                    },\n                    'MMM': function (value) {\n                        return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value));\n                    },\n                    'MM': function (value) {\n                        return this.setMonth(1 * value - 1);\n                    },\n                    'M': function (value) {\n                        return this.setMonth(1 * value - 1);\n                    },\n                    'yyyy': proto.setFullYear,\n                    'yy': function (value) {\n                        return this.setFullYear(2000 + 1 * value);\n                    },\n                    'y': proto.setFullYear\n                };\n\n                var regex, setMap;\n\n                $dateParser.init = function () {\n                    $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n                    regex = regExpForFormat($dateParser.$format);\n                    setMap = setMapForFormat($dateParser.$format);\n                };\n\n                $dateParser.isValid = function (date) {\n                    if (angular.isDate(date)) return !isNaN(date.getTime());\n                    return regex.test(date);\n                };\n\n                $dateParser.parse = function (value, baseDate, format, timezone) {\n                    // check for date format special names\n                    if (format) format = $locale.DATETIME_FORMATS[format] || format;\n                    if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n                    var formatRegex = format ? regExpForFormat(format) : regex;\n                    var formatSetMap = format ? setMapForFormat(format) : setMap;\n                    var matches = formatRegex.exec(value);\n                    if (!matches) return false;\n                    // use custom ParseDate object to set parsed values\n                    var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n                    for (var i = 0; i < matches.length - 1; i++) {\n                        formatSetMap[i] && formatSetMap[i].call(date, matches[i + 1]);\n                    }\n                    // convert back to native Date object\n                    var newDate = date.toDate();\n\n                    // check new native Date object for day values overflow\n                    if (parseInt(date.day, 10) !== newDate.getDate()) {\n                        return false;\n                    }\n\n                    return newDate;\n                };\n\n                $dateParser.getDateForAttribute = function (key, value) {\n                    var date;\n\n                    if (value === 'today') {\n                        var today = new Date();\n                        date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n                    } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n                        date = new Date(value.substr(1, value.length - 2));\n                    } else if (isNumeric(value)) {\n                        date = new Date(parseInt(value, 10));\n                    } else if (angular.isString(value) && 0 === value.length) { // Reset date\n                        date = key === 'minDate' ? -Infinity : +Infinity;\n                    } else {\n                        date = new Date(value);\n                    }\n\n                    return date;\n                };\n\n                $dateParser.getTimeForAttribute = function (key, value) {\n                    var time;\n\n                    if (value === 'now') {\n                        time = new Date().setFullYear(1970, 0, 1);\n                    } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n                        time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n                    } else if (isNumeric(value)) {\n                        time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n                    } else if (angular.isString(value) && 0 === value.length) { // Reset time\n                        time = key === 'minTime' ? -Infinity : +Infinity;\n                    } else {\n                        time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n                    }\n\n                    return time;\n                };\n\n                /* Handle switch to/from daylight saving.\n                 * Hours may be non-zero on daylight saving cut-over:\n                 * > 12 when midnight changeover, but then cannot generate\n                 * midnight datetime, so jump to 1AM, otherwise reset.\n                 * @param  date  (Date) the date to check\n                 * @return  (Date) the corrected date\n                 *\n                 * __ copied from jquery ui datepicker __\n                 */\n                $dateParser.daylightSavingAdjust = function (date) {\n                    if (!date) {\n                        return null;\n                    }\n                    date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n                    return date;\n                };\n\n                /* Correct the date for timezone offset.\n                 * @param  date  (Date) the date to adjust\n                 * @param  timezone  (string) the timezone to adjust for\n                 * @param  undo  (boolean) to add or subtract timezone offset\n                 * @return  (Date) the corrected date\n                 */\n                $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n                    if (!date) {\n                        return null;\n                    }\n                    // Right now, only 'UTC' is supported.\n                    if (timezone && timezone === 'UTC') {\n                        date = new Date(date.getTime());\n                        date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n                    }\n                    return date;\n                };\n\n                // Private functions\n\n                function setMapForFormat(format) {\n                    var keys = Object.keys(setFnMap), i;\n                    var map = [], sortedMap = [];\n                    // Map to setFn\n                    var clonedFormat = format;\n                    for (i = 0; i < keys.length; i++) {\n                        if (format.split(keys[i]).length > 1) {\n                            var index = clonedFormat.search(keys[i]);\n                            format = format.split(keys[i]).join('');\n                            if (setFnMap[keys[i]]) {\n                                map[index] = setFnMap[keys[i]];\n                            }\n                        }\n                    }\n                    // Sort result map\n                    angular.forEach(map, function (v) {\n                        // conditional required since angular.forEach broke around v1.2.21\n                        // related pr: https://github.com/angular/angular.js/pull/8525\n                        if (v) sortedMap.push(v);\n                    });\n                    return sortedMap;\n                }\n\n                function escapeReservedSymbols(text) {\n                    return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n                }\n\n                function regExpForFormat(format) {\n                    var keys = Object.keys(regExpMap), i;\n\n                    var re = format;\n                    // Abstract replaces to avoid collisions\n                    for (i = 0; i < keys.length; i++) {\n                        re = re.split(keys[i]).join('${' + i + '}');\n                    }\n                    // Replace abstracted values\n                    for (i = 0; i < keys.length; i++) {\n                        re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n                    }\n                    format = escapeReservedSymbols(format);\n\n                    return new RegExp('^' + re + '$', ['i']);\n                }\n\n                $dateParser.init();\n                return $dateParser;\n\n            };\n\n            return DateParserFactory;\n\n        };\n\n    });\n",
    "'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [\n    'mgcrea.ngStrap.helpers.dateParser',\n    'mgcrea.ngStrap.helpers.dateFormatter',\n    'mgcrea.ngStrap.tooltip'])\n\n    .provider('$datepicker', function () {\n\n        var defaults = this.defaults = {\n            animation: 'am-fade',\n            //uncommenting the following line will break backwards compatability\n            // prefixEvent: 'datepicker',\n            prefixClass: 'datepicker',\n            placement: 'bottom-left',\n            template: 'template/datetimepicker/datepicker.tpl.html',\n            trigger: 'focus',\n            container: false,\n            keyboard: true,\n            html: false,\n            delay: 0,\n            // lang: $locale.id,\n            useNative: false,\n            dateType: 'date',\n            dateFormat: 'shortDate',\n            timezone: null,\n            modelDateFormat: null,\n            dayFormat: 'dd',\n            monthFormat: 'MMM',\n            yearFormat: 'yyyy',\n            monthTitleFormat: 'MMMM yyyy',\n            yearTitleFormat: 'yyyy',\n            strictFormat: false,\n            autoclose: false,\n            minDate: -Infinity,\n            maxDate: +Infinity,\n            startView: 0,\n            minView: 0,\n            startWeek: 0,\n            daysOfWeekDisabled: '',\n            iconLeft: 'glyphicon glyphicon-chevron-left',\n            iconRight: 'glyphicon glyphicon-chevron-right'\n        };\n\n        this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $bsTooltip, $timeout) {\n\n            var bodyEl = angular.element($window.document.body);\n            var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n            var isTouch = ('createTouch' in $window.document) && isNative;\n            if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n            function DatepickerFactory(element, controller, config) {\n\n                var $datepicker = $bsTooltip(element, angular.extend({}, defaults, config));\n                var parentScope = config.scope;\n                var options = $datepicker.$options;\n                var scope = $datepicker.$scope;\n                if (options.startView) options.startView -= options.minView;\n\n                // View vars\n\n                var pickerViews = datepickerViews($datepicker);\n                $datepicker.$views = pickerViews.views;\n                var viewDate = pickerViews.viewDate;\n                scope.$mode = options.startView;\n                scope.$iconLeft = options.iconLeft;\n                scope.$iconRight = options.iconRight;\n                var $picker = $datepicker.$views[scope.$mode];\n\n                // Scope methods\n\n                scope.$select = function (date) {\n                    $datepicker.select(date);\n                };\n                scope.$selectPane = function (value) {\n                    $datepicker.$selectPane(value);\n                };\n                scope.$toggleMode = function () {\n                    $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n                };\n\n                scope.$today = function () {\n                    $datepicker.select(new Date());\n                };\n\n                scope.$clear = function () {\n                    controller.$setViewValue('');\n                    controller.$commitViewValue();\n                    controller.$modelValue = null;\n                    controller.$dateValue = null;\n                    controller.$render();\n                    $timeout(function () {\n                        $datepicker.hide(true);\n                    });\n                };\n\n                scope.$close = function () {\n                    $timeout(function () {\n                        $datepicker.hide(true);\n                    });\n                };\n\n                // Public methods\n\n                $datepicker.update = function (date) {\n                    // console.warn('$datepicker.update() newValue=%o', date);\n                    if (angular.isDate(date) && !isNaN(date.getTime())) {\n                        $datepicker.$date = date;\n                        $picker.update.call($picker, date);\n                    }\n                    // Build only if pristine\n                    $datepicker.$build(true);\n                };\n\n                $datepicker.updateDisabledDates = function (dateRanges) {\n                    options.disabledDateRanges = dateRanges;\n                    for (var i = 0, l = scope.rows.length; i < l; i++) {\n                        angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n                    }\n                };\n\n                $datepicker.select = function (date, keep) {\n                    // console.warn('$datepicker.select', date, scope.$mode);\n                    if (!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n                    if (!scope.$mode || keep) {\n                        controller.$setViewValue(angular.copy(date));\n                        controller.$render();\n                        if (options.autoclose && !keep) {\n                            $timeout(function () {\n                                $datepicker.hide(true);\n                            });\n                        }\n                    } else {\n                        angular.extend(viewDate, {\n                            year: date.getFullYear(),\n                            month: date.getMonth(),\n                            date: date.getDate()\n                        });\n                        $datepicker.setMode(scope.$mode - 1);\n                        $datepicker.$build();\n                    }\n                };\n\n                $datepicker.setMode = function (mode) {\n                    // console.warn('$datepicker.setMode', mode);\n                    scope.$mode = mode;\n                    $picker = $datepicker.$views[scope.$mode];\n                    $datepicker.$build();\n                };\n\n                // Protected methods\n\n                $datepicker.$build = function (pristine) {\n                    // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n                    if (pristine === true && $picker.built) return;\n                    if (pristine === false && !$picker.built) return;\n                    $picker.build.call($picker);\n                };\n\n                $datepicker.$updateSelected = function () {\n                    for (var i = 0, l = scope.rows.length; i < l; i++) {\n                        angular.forEach(scope.rows[i], updateSelected);\n                    }\n                };\n\n                $datepicker.$isSelected = function (date) {\n                    return $picker.isSelected(date);\n                };\n\n                $datepicker.$setDisabledEl = function (el) {\n                    el.disabled = $picker.isDisabled(el.date);\n                };\n\n                $datepicker.$selectPane = function (value) {\n                    var steps = $picker.steps;\n                    // set targetDate to first day of month to avoid problems with\n                    // date values rollover. This assumes the viewDate does not\n                    // depend on the day of the month\n                    var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n                    angular.extend(viewDate, {\n                        year: targetDate.getUTCFullYear(),\n                        month: targetDate.getUTCMonth(),\n                        date: targetDate.getUTCDate()\n                    });\n                    $datepicker.$build();\n                };\n\n                $datepicker.$onMouseDown = function (evt) {\n                    // Prevent blur on mousedown on .dropdown-menu\n                    evt.preventDefault();\n                    evt.stopPropagation();\n                    // Emulate click for mobile devices\n                    if (isTouch) {\n                        var targetEl = angular.element(evt.target);\n                        if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n                            targetEl = targetEl.parent();\n                        }\n                        targetEl.triggerHandler('click');\n                    }\n                };\n\n                $datepicker.$onKeyDown = function (evt) {\n                    if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n                    evt.preventDefault();\n                    evt.stopPropagation();\n\n                    if (evt.keyCode === 13) {\n                        if (!scope.$mode) {\n                            return $datepicker.hide(true);\n                        } else {\n                            return scope.$apply(function () {\n                                $datepicker.setMode(scope.$mode - 1);\n                            });\n                        }\n                    }\n\n                    // Navigate with keyboard\n                    $picker.onKeyDown(evt);\n                    parentScope.$digest();\n                };\n\n                // Private\n\n                function updateSelected(el) {\n                    el.selected = $datepicker.$isSelected(el.date);\n                }\n\n                function focusElement() {\n                    element[0].focus();\n                }\n\n                // Overrides\n\n                var _init = $datepicker.init;\n                $datepicker.init = function () {\n                    if (isNative && options.useNative) {\n                        element.prop('type', 'date');\n                        element.css('-webkit-appearance', 'textfield');\n                        return;\n                    } else if (isTouch) {\n                        element.prop('type', 'text');\n                        element.attr('readonly', 'true');\n                        element.on('click', focusElement);\n                    }\n                    _init();\n                };\n\n                var _destroy = $datepicker.destroy;\n                $datepicker.destroy = function () {\n                    if (isNative && options.useNative) {\n                        element.off('click', focusElement);\n                    }\n                    _destroy();\n                };\n\n                var _show = $datepicker.show;\n                $datepicker.show = function () {\n                    _show();\n                    // use timeout to hookup the events to prevent\n                    // event bubbling from being processed imediately.\n                    $timeout(function () {\n                        // if $datepicker is no longer showing, don't setup events\n                        if (!$datepicker.$isShown) return;\n                        $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n                        if (options.keyboard) {\n                            element.on('keydown', $datepicker.$onKeyDown);\n                        }\n                    }, 0, false);\n                };\n\n                var _hide = $datepicker.hide;\n                $datepicker.hide = function (blur) {\n                    if (!$datepicker.$isShown) return;\n                    $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n                    if (options.keyboard) {\n                        element.off('keydown', $datepicker.$onKeyDown);\n                    }\n                    _hide(blur);\n                };\n\n                return $datepicker;\n\n            }\n\n            DatepickerFactory.defaults = defaults;\n            return DatepickerFactory;\n\n        };\n\n    })\n\n    .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n        var defaults = $datepicker.defaults;\n        var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n        return {\n            restrict: 'EAC',\n            require: 'ngModel',\n            link: function postLink(scope, element, attr, controller) {\n\n                // Directive options\n                var options = {scope: scope, controller: controller};\n                angular.forEach(['placement', 'container', 'delay', 'trigger', 'html', 'animation', 'template', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n                    if (angular.isDefined(attr[key])) options[key] = attr[key];\n                });\n\n                // use string regex match boolean attr falsy values, leave truthy values be\n                var falseValueRegExp = /^(false|0|)$/i;\n                angular.forEach(['html', 'container', 'autoclose', 'useNative'], function (key) {\n                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n                        options[key] = false;\n                });\n\n                // Visibility binding support\n                attr.bsShow && scope.$watch(attr.bsShow, function (newValue, oldValue) {\n                    if (!datepicker || !angular.isDefined(newValue)) return;\n                    if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n                    newValue === true ? datepicker.show() : datepicker.hide();\n                });\n\n                // Initialize datepicker\n                var datepicker = $datepicker(element, controller, options);\n                options = datepicker.$options;\n                // Set expected iOS format\n                if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n                var lang = options.lang;\n\n                var formatDate = function (date, format) {\n                    return $dateFormatter.formatDate(date, format, lang);\n                };\n\n                var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n                // Observe attributes for changes\n                angular.forEach(['minDate', 'maxDate'], function (key) {\n                    // console.warn('attr.$observe(%s)', key, attr[key]);\n                    angular.isDefined(attr[key]) && attr.$observe(key, function (newValue) {\n                        // console.warn('attr.$observe(%s)=%o', key, newValue);\n                        datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n                        // Build only if dirty\n                        !isNaN(datepicker.$options[key]) && datepicker.$build(false);\n                        validateAgainstMinMaxDate(controller.$dateValue);\n                    });\n                });\n\n                // Watch model for changes\n                scope.$watch(attr.ngModel, function (newValue, oldValue) {\n                    datepicker.update(controller.$dateValue);\n                }, true);\n\n                // Normalize undefined/null/empty array,\n                // so that we don't treat changing from undefined->null as a change.\n                function normalizeDateRanges(ranges) {\n                    if (!ranges || !ranges.length) return null;\n                    return ranges;\n                }\n\n                if (angular.isDefined(attr.disabledDates)) {\n                    scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n                        disabledRanges = normalizeDateRanges(disabledRanges);\n                        previousValue = normalizeDateRanges(previousValue);\n\n                        if (disabledRanges) {\n                            datepicker.updateDisabledDates(disabledRanges);\n                        }\n                    });\n                }\n\n                function validateAgainstMinMaxDate(parsedDate) {\n                    if (!angular.isDate(parsedDate)) return;\n                    var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n                    var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n                    var isValid = isMinValid && isMaxValid;\n                    controller.$setValidity('date', isValid);\n                    controller.$setValidity('min', isMinValid);\n                    controller.$setValidity('max', isMaxValid);\n                    // Only update the model when we have a valid date\n                    if (isValid) controller.$dateValue = parsedDate;\n                }\n\n                // viewValue -> $parsers -> modelValue\n                controller.$parsers.unshift(function (viewValue) {\n                    // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n                    var date;\n                    // Null values should correctly reset the model value & validity\n                    if (!viewValue) {\n                        controller.$setValidity('date', true);\n                        // BREAKING CHANGE:\n                        // return null (not undefined) when input value is empty, so angularjs 1.3\n                        // ngModelController can go ahead and run validators, like ngRequired\n                        return null;\n                    }\n                    var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n                    if (!parsedDate || isNaN(parsedDate.getTime())) {\n                        controller.$setValidity('date', false);\n                        // return undefined, causes ngModelController to\n                        // invalidate model value\n                        return;\n                    } else {\n                        validateAgainstMinMaxDate(parsedDate);\n                    }\n\n                    if (options.dateType === 'string') {\n                        date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n                        return formatDate(date, options.modelDateFormat || options.dateFormat);\n                    }\n                    date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n                    if (options.dateType === 'number') {\n                        return date.getTime();\n                    } else if (options.dateType === 'unix') {\n                        return date.getTime() / 1000;\n                    } else if (options.dateType === 'iso') {\n                        return date.toISOString();\n                    } else {\n                        return new Date(date);\n                    }\n                });\n\n                // modelValue -> $formatters -> viewValue\n                controller.$formatters.push(function (modelValue) {\n                    // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n                    var date;\n                    if (angular.isUndefined(modelValue) || modelValue === null) {\n                        date = NaN;\n                    } else if (angular.isDate(modelValue)) {\n                        date = modelValue;\n                    } else if (options.dateType === 'string') {\n                        date = dateParser.parse(modelValue, null, options.modelDateFormat);\n                    } else if (options.dateType === 'unix') {\n                        date = new Date(modelValue * 1000);\n                    } else {\n                        date = new Date(modelValue);\n                    }\n                    // Setup default value?\n                    // if(isNaN(date.getTime())) {\n                    //   var today = new Date();\n                    //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n                    // }\n                    controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n                    return getDateFormattedString();\n                });\n\n                // viewValue -> element\n                controller.$render = function () {\n                    // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n                    element.val(getDateFormattedString());\n                };\n\n                function getDateFormattedString() {\n                    return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n                }\n\n                // Garbage collection\n                scope.$on('$destroy', function () {\n                    if (datepicker) datepicker.destroy();\n                    options = null;\n                    datepicker = null;\n                });\n\n            }\n        };\n\n    })\n\n    .provider('datepickerViews', function () {\n\n        var defaults = this.defaults = {\n            dayFormat: 'dd',\n            daySplit: 7\n        };\n\n        // Split array into smaller arrays\n        function split(arr, size) {\n            var arrays = [];\n            while (arr.length > 0) {\n                arrays.push(arr.splice(0, size));\n            }\n            return arrays;\n        }\n\n        // Modulus operator\n        function mod(n, m) {\n            return ((n % m) + m) % m;\n        }\n\n        this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n            return function (picker) {\n\n                var scope = picker.$scope;\n                var options = picker.$options;\n\n                var lang = options.lang;\n                var formatDate = function (date, format) {\n                    return $dateFormatter.formatDate(date, format, lang);\n                };\n                var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n                var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n                var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n                var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n                var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n                var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n                var views = [{\n                    format: options.dayFormat,\n                    split: 7,\n                    steps: {month: 1},\n                    update: function (date, force) {\n                        if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n                            angular.extend(viewDate, {\n                                year: picker.$date.getFullYear(),\n                                month: picker.$date.getMonth(),\n                                date: picker.$date.getDate()\n                            });\n                            picker.$build();\n                        } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                            // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                            // in $datepicker.$selectPane, so picker would not update selected day display if\n                            // user picks first day of the new month.\n                            // As a workaround, we are always forcing update when picked date is first day of month.\n                            viewDate.date = picker.$date.getDate();\n                            picker.$updateSelected();\n                        }\n                    },\n                    build: function () {\n                        var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1), firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n                        var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5), firstDateOffset = firstDate.getTimezoneOffset();\n                        var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n                        // Handle daylight time switch\n                        if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n                        var days = [], day;\n                        for (var i = 0; i < 42; i++) { // < 7 * 6\n                            day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n                            days.push({\n                                date: day,\n                                isToday: day.toDateString() === today,\n                                label: formatDate(day, this.format),\n                                selected: picker.$date && this.isSelected(day),\n                                muted: day.getMonth() !== viewDate.month,\n                                disabled: this.isDisabled(day)\n                            });\n                        }\n                        scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n                        scope.showLabels = true;\n                        scope.labels = weekDaysLabelsHtml;\n                        scope.rows = split(days, this.split);\n                        this.built = true;\n                    },\n                    isSelected: function (date) {\n                        return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n                    },\n                    isDisabled: function (date) {\n                        var time = date.getTime();\n\n                        // Disabled because of min/max date.\n                        if (time < options.minDate || time > options.maxDate) return true;\n\n                        // Disabled due to being a disabled day of the week\n                        if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n                        // Disabled because of disabled date range.\n                        if (options.disabledDateRanges) {\n                            for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                                    return true;\n                                }\n                            }\n                        }\n\n                        return false;\n                    },\n                    onKeyDown: function (evt) {\n                        if (!picker.$date) {\n                            return;\n                        }\n                        var actualTime = picker.$date.getTime();\n                        var newDate;\n\n                        if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n                        else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n                        else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n                        else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n                        if (!this.isDisabled(newDate)) picker.select(newDate, true);\n                    }\n                }, {\n                    name: 'month',\n                    format: options.monthFormat,\n                    split: 4,\n                    steps: {year: 1},\n                    update: function (date, force) {\n                        if (!this.built || date.getFullYear() !== viewDate.year) {\n                            angular.extend(viewDate, {\n                                year: picker.$date.getFullYear(),\n                                month: picker.$date.getMonth(),\n                                date: picker.$date.getDate()\n                            });\n                            picker.$build();\n                        } else if (date.getMonth() !== viewDate.month) {\n                            angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                            picker.$updateSelected();\n                        }\n                    },\n                    build: function () {\n                        var firstMonth = new Date(viewDate.year, 0, 1);\n                        var months = [], month;\n                        for (var i = 0; i < 12; i++) {\n                            month = new Date(viewDate.year, i, 1);\n                            months.push({\n                                date: month,\n                                label: formatDate(month, this.format),\n                                selected: picker.$isSelected(month),\n                                disabled: this.isDisabled(month)\n                            });\n                        }\n                        scope.title = formatDate(month, options.yearTitleFormat);\n                        scope.showLabels = false;\n                        scope.rows = split(months, this.split);\n                        this.built = true;\n                    },\n                    isSelected: function (date) {\n                        return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n                    },\n                    isDisabled: function (date) {\n                        var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n                        return lastDate < options.minDate || date.getTime() > options.maxDate;\n                    },\n                    onKeyDown: function (evt) {\n                        if (!picker.$date) {\n                            return;\n                        }\n                        var actualMonth = picker.$date.getMonth();\n                        var newDate = new Date(picker.$date);\n\n                        if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n                        else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n                        else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n                        else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n                        if (!this.isDisabled(newDate)) picker.select(newDate, true);\n                    }\n                }, {\n                    name: 'year',\n                    format: options.yearFormat,\n                    split: 4,\n                    steps: {year: 12},\n                    update: function (date, force) {\n                        if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n                            angular.extend(viewDate, {\n                                year: picker.$date.getFullYear(),\n                                month: picker.$date.getMonth(),\n                                date: picker.$date.getDate()\n                            });\n                            picker.$build();\n                        } else if (date.getFullYear() !== viewDate.year) {\n                            angular.extend(viewDate, {\n                                year: picker.$date.getFullYear(),\n                                month: picker.$date.getMonth(),\n                                date: picker.$date.getDate()\n                            });\n                            picker.$updateSelected();\n                        }\n                    },\n                    build: function () {\n                        var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n                        var years = [], year;\n                        for (var i = 0; i < 12; i++) {\n                            year = new Date(firstYear + i, 0, 1);\n                            years.push({\n                                date: year,\n                                label: formatDate(year, this.format),\n                                selected: picker.$isSelected(year),\n                                disabled: this.isDisabled(year)\n                            });\n                        }\n                        scope.title = years[0].label + '-' + years[years.length - 1].label;\n                        scope.showLabels = false;\n                        scope.rows = split(years, this.split);\n                        this.built = true;\n                    },\n                    isSelected: function (date) {\n                        return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n                    },\n                    isDisabled: function (date) {\n                        var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n                        return lastDate < options.minDate || date.getTime() > options.maxDate;\n                    },\n                    onKeyDown: function (evt) {\n                        if (!picker.$date) {\n                            return;\n                        }\n                        var actualYear = picker.$date.getFullYear(),\n                            newDate = new Date(picker.$date);\n\n                        if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n                        else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n                        else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n                        else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n                        if (!this.isDisabled(newDate)) picker.select(newDate, true);\n                    }\n                }];\n\n                return {\n                    views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n                    viewDate: viewDate\n                };\n\n            };\n\n        };\n\n    });\n",
    "(function () {\n\n    'use strict';\n\n    angular.module('ui.datetimepicker', [\n        'mgcrea.ngStrap.datepicker',\n        'mgcrea.ngStrap.timepicker'])\n\n        .config(function ($datepickerProvider, $timepickerProvider) {\n            angular.extend($datepickerProvider.defaults, {\n                dateType: 'unix',\n                startWeek: 1,\n                autoclose: 1\n            });\n\n            angular.extend($timepickerProvider.defaults, {\n                timeFormat: 'HH:mm:ss',\n                timeType: 'unix',\n                length: 10,\n                autoclose: 0\n            });\n        })\n\n        .directive('isDirty', function () {\n            return {\n                restrict: 'AE',\n                require: 'ngModel',\n                link: function (scope, element, attrs, ngModelCtrl) {\n                    attrs.$observe('isDirty', function (value) {\n                        if (value) {\n                            ngModelCtrl.$setDirty();\n                        }\n                    })\n                }\n            };\n        })\n\n        .directive('datetimepicker', function ($parse, $dateParser, $datepicker, $timepicker, $locale) {\n\n            function getTimestampFromDate(date) {\n                var timestamp = date;\n\n                if (date && angular.isDate(date)) {\n                    timestamp = moment(date).unix();\n                }\n\n                return timestamp;\n            }\n\n            function getDateFromTimestamp(timestamp) {\n                var date = timestamp;\n\n                if (timestamp && !angular.isDate(timestamp)) {\n                    date = moment.unix(timestamp).toDate();\n                }\n\n                return date;\n            }\n\n            function dashCase(name) {\n                return name.replace(/[A-Z]/g, function (letter, pos) {\n                    return (pos ? '-' : '') + letter.toLowerCase();\n                });\n            }\n\n            return {\n                restrict: 'EA',\n                require: 'ngModel',\n                replace: true,\n                priority: 1,\n                scope: {\n                    ngModel: '='\n                },\n                templateUrl: 'template/datetimepicker/datetimepicker.html',\n                compile: function compile(template, attrs) {\n                    var inputs;\n                    var dateInput;\n                    var timeInput;\n\n                    inputs = template.find('input');\n                    dateInput = angular.element(inputs[0]);\n                    timeInput = angular.element(inputs [1]);\n\n                    angular.forEach(['autoclose', 'dateFormat', 'dateType', 'ngDisabled'], function (key) {\n                        if (angular.isDefined(attrs[key])) {\n                            dateInput.attr(dashCase(key), attrs[key]);\n                        }\n                    });\n\n                    angular.forEach(['autoclose', 'timeFormat', 'timeType', 'ngDisabled'], function (key) {\n                        if (angular.isDefined(attrs[key])) {\n                            timeInput.attr(dashCase(key), attrs[key]);\n                        }\n                    });\n\n                    if (angular.isDefined(attrs['name'])) {\n                        dateInput.attr('name', attrs['name']);\n                        timeInput.attr('name', attrs['name'] + 'Time');\n                    }\n\n                    return function postLink(scope, element, attrs, ngModelCtrl) {\n                        var dateFormat;\n                        var timeFormat;\n\n                        element.removeClass('form-control');\n\n                        if (angular.isDefined(attrs['dateOnly'])) {\n                            scope.dateOnly = attrs['dateOnly'] === 'true';\n                        }\n\n                        if (angular.isDefined(attrs['dateFormat'])) {\n                            dateFormat = attrs.dateFormat;\n                        } else {\n                            dateFormat = $datepicker.defaults.dateFormat;\n                        }\n\n                        scope.dateFormat = $locale.DATETIME_FORMATS[dateFormat] || dateFormat;\n\n                        if (angular.isDefined(attrs['timeFormat'])) {\n                            timeFormat = attrs.timeFormat;\n                        } else {\n                            timeFormat = $timepicker.defaults.timeFormat;\n                        }\n\n                        scope.timeFormat = $locale.DATETIME_FORMATS[timeFormat] || timeFormat;\n\n                        if (angular.isDefined(attrs['dateType'])) {\n                            scope.dateType = attrs.dateType;\n                        } else {\n                            scope.dateType = $datepicker.defaults.dateType;\n                        }\n\n                        scope.touchDate = function () {\n                            scope.isDirty = true;\n                        };\n\n                        attrs.$observe('minDate', function (value) {\n                            if (scope.dateType === 'unix') {\n                                scope.minDate = getDateFromTimestamp(value);\n                            } else {\n                                scope.minDate = value;\n                            }\n                        });\n\n                        attrs.$observe('maxDate', function (value) {\n                            if (scope.dateType !== 'unix') {\n                                scope.maxDate = getDateFromTimestamp(value);\n                            } else {\n                                scope.minDate = value;\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    );\n\n}());\n",
    "'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n    .factory('dimensions', function ($document, $window) {\n\n        var jqLite = angular.element;\n        var fn = {};\n\n        /**\n         * Test the element nodeName\n         * @param element\n         * @param name\n         */\n        var nodeName = fn.nodeName = function (element, name) {\n            return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n        };\n\n        /**\n         * Returns the element computed style\n         * @param element\n         * @param prop\n         * @param extra\n         */\n        fn.css = function (element, prop, extra) {\n            var value;\n            if (element.currentStyle) { //IE\n                value = element.currentStyle[prop];\n            } else if (window.getComputedStyle) {\n                value = window.getComputedStyle(element)[prop];\n            } else {\n                value = element.style[prop];\n            }\n            return extra === true ? parseFloat(value) || 0 : value;\n        };\n\n        /**\n         * Provides read-only equivalent of jQuery's offset function:\n         * @required-by bootstrap-tooltip, bootstrap-affix\n         * @url http://api.jquery.com/offset/\n         * @param element\n         */\n        fn.offset = function (element) {\n            var boxRect = element.getBoundingClientRect();\n            var docElement = element.ownerDocument;\n            return {\n                width: boxRect.width || element.offsetWidth,\n                height: boxRect.height || element.offsetHeight,\n                top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n                left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n            };\n        };\n\n        /**\n         * Provides set equivalent of jQuery's offset function:\n         * @required-by bootstrap-tooltip\n         * @url http://api.jquery.com/offset/\n         * @param element\n         * @param options\n         * @param i\n         */\n        fn.setOffset = function (element, options, i) {\n            var curPosition,\n                curLeft,\n                curCSSTop,\n                curTop,\n                curOffset,\n                curCSSLeft,\n                calculatePosition,\n                position = fn.css(element, 'position'),\n                curElem = angular.element(element),\n                props = {};\n\n            // Set position first, in-case top/left are set even on static elem\n            if (position === 'static') {\n                element.style.position = 'relative';\n            }\n\n            curOffset = fn.offset(element);\n            curCSSTop = fn.css(element, 'top');\n            curCSSLeft = fn.css(element, 'left');\n            calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n            // Need to be able to calculate position if either\n            // top or left is auto and position is either absolute or fixed\n            if (calculatePosition) {\n                curPosition = fn.position(element);\n                curTop = curPosition.top;\n                curLeft = curPosition.left;\n            } else {\n                curTop = parseFloat(curCSSTop) || 0;\n                curLeft = parseFloat(curCSSLeft) || 0;\n            }\n\n            if (angular.isFunction(options)) {\n                options = options.call(element, i, curOffset);\n            }\n\n            if (options.top !== null) {\n                props.top = (options.top - curOffset.top) + curTop;\n            }\n            if (options.left !== null) {\n                props.left = (options.left - curOffset.left) + curLeft;\n            }\n\n            if ('using' in options) {\n                options.using.call(curElem, props);\n            } else {\n                curElem.css({\n                    top: props.top + 'px',\n                    left: props.left + 'px'\n                });\n            }\n        };\n\n        /**\n         * Provides read-only equivalent of jQuery's position function\n         * @required-by bootstrap-tooltip, bootstrap-affix\n         * @url http://api.jquery.com/offset/\n         * @param element\n         */\n        fn.position = function (element) {\n\n            var offsetParentRect = {top: 0, left: 0},\n                offsetParentElement,\n                offset;\n\n            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n            if (fn.css(element, 'position') === 'fixed') {\n\n                // We assume that getBoundingClientRect is available when computed position is fixed\n                offset = element.getBoundingClientRect();\n\n            } else {\n\n                // Get *real* offsetParentElement\n                offsetParentElement = offsetParent(element);\n\n                // Get correct offsets\n                offset = fn.offset(element);\n                if (!nodeName(offsetParentElement, 'html')) {\n                    offsetParentRect = fn.offset(offsetParentElement);\n                }\n\n                // Add offsetParent borders\n                offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n                offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n            }\n\n            // Subtract parent offsets and element margins\n            return {\n                width: element.offsetWidth,\n                height: element.offsetHeight,\n                top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n                left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n            };\n\n        };\n\n        /**\n         * Returns the closest, non-statically positioned offsetParent of a given element\n         * @required-by fn.position\n         * @param element\n         */\n        var offsetParent = function offsetParentElement(element) {\n            var docElement = element.ownerDocument;\n            var offsetParent = element.offsetParent || docElement;\n            if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n            while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n                offsetParent = offsetParent.offsetParent;\n            }\n            return offsetParent || docElement.documentElement;\n        };\n\n        /**\n         * Provides equivalent of jQuery's height function\n         * @required-by bootstrap-affix\n         * @url http://api.jquery.com/height/\n         * @param element\n         * @param outer\n         */\n        fn.height = function (element, outer) {\n            var value = element.offsetHeight;\n            if (outer) {\n                value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n            } else {\n                value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n            }\n            return value;\n        };\n\n        /**\n         * Provides equivalent of jQuery's width function\n         * @required-by bootstrap-affix\n         * @url http://api.jquery.com/width/\n         * @param element\n         * @param outer\n         */\n        fn.width = function (element, outer) {\n            var value = element.offsetWidth;\n            if (outer) {\n                value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n            } else {\n                value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n            }\n            return value;\n        };\n\n        return fn;\n\n    });\n",
    "'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', [\n    'mgcrea.ngStrap.helpers.dateParser',\n    'mgcrea.ngStrap.helpers.dateFormatter',\n    'mgcrea.ngStrap.tooltip'])\n\n    .provider('$timepicker', function () {\n\n        var defaults = this.defaults = {\n            animation: 'am-fade',\n            //uncommenting the following line will break backwards compatability\n            // prefixEvent: 'timepicker',\n            prefixClass: 'timepicker',\n            placement: 'bottom-left',\n            template: 'template/datetimepicker/timepicker.tpl.html',\n            trigger: 'focus',\n            container: false,\n            keyboard: true,\n            html: false,\n            delay: 0,\n            // lang: $locale.id,\n            useNative: true,\n            timeType: 'date',\n            timeFormat: 'shortTime',\n            timezone: null,\n            modelTimeFormat: null,\n            autoclose: false,\n            minTime: -Infinity,\n            maxTime: +Infinity,\n            length: 5,\n            hourStep: 1,\n            minuteStep: 5,\n            secondStep: 5,\n            roundDisplay: false,\n            iconUp: 'glyphicon glyphicon-chevron-up',\n            iconDown: 'glyphicon glyphicon-chevron-down',\n            arrowBehavior: 'pager'\n        };\n\n        this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $bsTooltip, $timeout) {\n\n            var bodyEl = angular.element($window.document.body);\n            var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n            var isTouch = ('createTouch' in $window.document) && isNative;\n            if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n            function timepickerFactory(element, controller, config) {\n\n                var $timepicker = $bsTooltip(element, angular.extend({}, defaults, config));\n                var parentScope = config.scope;\n                var options = $timepicker.$options;\n                var scope = $timepicker.$scope;\n\n                var lang = options.lang;\n                var formatDate = function (date, format, timezone) {\n                    return $dateFormatter.formatDate(date, format, lang, timezone);\n                };\n\n                function floorMinutes(time) {\n                    // coeff used to floor current time to nearest minuteStep interval\n                    var coeff = 1000 * 60 * options.minuteStep;\n                    return new Date(Math.floor(time.getTime() / coeff) * coeff);\n                }\n\n                // View vars\n\n                var selectedIndex = 0;\n                var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n                var startDate = controller.$dateValue || defaultDate;\n                var viewDate = {\n                    hour: startDate.getHours(),\n                    meridian: startDate.getHours() < 12,\n                    minute: startDate.getMinutes(),\n                    second: startDate.getSeconds(),\n                    millisecond: startDate.getMilliseconds()\n                };\n\n                var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n                var hoursFormat = $dateFormatter.hoursFormat(format),\n                    timeSeparator = $dateFormatter.timeSeparator(format),\n                    minutesFormat = $dateFormatter.minutesFormat(format),\n                    secondsFormat = $dateFormatter.secondsFormat(format),\n                    showSeconds = $dateFormatter.showSeconds(format),\n                    showAM = $dateFormatter.showAM(format);\n\n                scope.$iconUp = options.iconUp;\n                scope.$iconDown = options.iconDown;\n\n                // Scope methods\n\n                scope.$select = function (date, index) {\n                    $timepicker.select(date, index);\n                };\n                scope.$moveIndex = function (value, index) {\n                    $timepicker.$moveIndex(value, index);\n                };\n                scope.$switchMeridian = function (date) {\n                    $timepicker.switchMeridian(date);\n                };\n\n                // Public methods\n\n                $timepicker.update = function (date) {\n                    // console.warn('$timepicker.update() newValue=%o', date);\n                    if (angular.isDate(date) && !isNaN(date.getTime())) {\n                        $timepicker.$date = date;\n                        angular.extend(viewDate, {\n                            hour: date.getHours(),\n                            minute: date.getMinutes(),\n                            second: date.getSeconds(),\n                            millisecond: date.getMilliseconds()\n                        });\n                        $timepicker.$build();\n                    } else if (!$timepicker.$isBuilt) {\n                        $timepicker.$build();\n                    }\n                };\n\n                $timepicker.select = function (date, index, keep) {\n                    // console.warn('$timepicker.select', date, scope.$mode);\n                    if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n                    if (!angular.isDate(date)) date = new Date(date);\n                    if (index === 0) controller.$dateValue.setHours(date.getHours());\n                    else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n                    else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n                    controller.$setViewValue(angular.copy(controller.$dateValue));\n                    controller.$render();\n                    if (options.autoclose && !keep) {\n                        $timeout(function () {\n                            $timepicker.hide(true);\n                        });\n                    }\n                };\n\n                $timepicker.switchMeridian = function (date) {\n                    if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n                        return;\n                    }\n                    var hours = (date || controller.$dateValue).getHours();\n                    controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n                    controller.$setViewValue(angular.copy(controller.$dateValue));\n                    controller.$render();\n                };\n\n                // Protected methods\n\n                $timepicker.$build = function () {\n                    // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n                    var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n                    var hours = [], hour;\n                    for (i = 0; i < options.length; i++) {\n                        hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n                        hours.push({\n                            date: hour,\n                            label: formatDate(hour, hoursFormat),\n                            selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n                            disabled: $timepicker.$isDisabled(hour, 0)\n                        });\n                    }\n                    var minutes = [], minute;\n                    for (i = 0; i < options.length; i++) {\n                        minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n                        minutes.push({\n                            date: minute,\n                            label: formatDate(minute, minutesFormat),\n                            selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n                            disabled: $timepicker.$isDisabled(minute, 1)\n                        });\n                    }\n                    var seconds = [], second;\n                    for (i = 0; i < options.length; i++) {\n                        second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n                        seconds.push({\n                            date: second,\n                            label: formatDate(second, secondsFormat),\n                            selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n                            disabled: $timepicker.$isDisabled(second, 2)\n                        });\n                    }\n\n                    var rows = [];\n                    for (i = 0; i < options.length; i++) {\n                        if (showSeconds) {\n                            rows.push([hours[i], minutes[i], seconds[i]]);\n                        } else {\n                            rows.push([hours[i], minutes[i]]);\n                        }\n                    }\n                    scope.rows = rows;\n                    scope.showSeconds = showSeconds;\n                    scope.showAM = showAM;\n                    scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n                    scope.timeSeparator = timeSeparator;\n                    $timepicker.$isBuilt = true;\n                };\n\n                $timepicker.$isSelected = function (date, index) {\n                    if (!$timepicker.$date) return false;\n                    else if (index === 0) {\n                        return date.getHours() === $timepicker.$date.getHours();\n                    } else if (index === 1) {\n                        return date.getMinutes() === $timepicker.$date.getMinutes();\n                    } else if (index === 2) {\n                        return date.getSeconds() === $timepicker.$date.getSeconds();\n                    }\n                };\n\n                $timepicker.$isDisabled = function (date, index) {\n                    var selectedTime;\n                    if (index === 0) {\n                        selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n                    } else if (index === 1) {\n                        selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n                    } else if (index === 2) {\n                        selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n                    }\n                    return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n                };\n\n                scope.$arrowAction = function (value, index) {\n                    if (options.arrowBehavior === 'picker') {\n                        $timepicker.$setTimeByStep(value, index);\n                    } else {\n                        $timepicker.$moveIndex(value, index);\n                    }\n                };\n\n                $timepicker.$setTimeByStep = function (value, index) {\n                    var newDate = new Date($timepicker.$date);\n                    var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n                    var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n                    var seconds = newDate.getSeconds(), secondsLength = formatDate(newDate, secondsFormat).length;\n                    if (index === 0) {\n                        newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n                    }\n                    else if (index === 1) {\n                        newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n                    }\n                    else if (index === 2) {\n                        newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n                    }\n                    $timepicker.select(newDate, index, true);\n                };\n\n                $timepicker.$moveIndex = function (value, index) {\n                    var targetDate;\n                    if (index === 0) {\n                        targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n                        angular.extend(viewDate, {hour: targetDate.getHours()});\n                    } else if (index === 1) {\n                        targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n                        angular.extend(viewDate, {minute: targetDate.getMinutes()});\n                    } else if (index === 2) {\n                        targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n                        angular.extend(viewDate, {second: targetDate.getSeconds()});\n                    }\n                    $timepicker.$build();\n                };\n\n                $timepicker.$onMouseDown = function (evt) {\n                    // Prevent blur on mousedown on .dropdown-menu\n                    if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n                    evt.stopPropagation();\n                    // Emulate click for mobile devices\n                    if (isTouch) {\n                        var targetEl = angular.element(evt.target);\n                        if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n                            targetEl = targetEl.parent();\n                        }\n                        targetEl.triggerHandler('click');\n                    }\n                };\n\n                $timepicker.$onKeyDown = function (evt) {\n                    if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n                    evt.preventDefault();\n                    evt.stopPropagation();\n\n                    // Close on enter\n                    if (evt.keyCode === 13) return $timepicker.hide(true);\n\n                    // Navigate with keyboard\n                    var newDate = new Date($timepicker.$date);\n                    var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n                    var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n                    var seconds = newDate.getSeconds(), secondsLength = formatDate(newDate, secondsFormat).length;\n                    var sepLength = 1;\n                    var lateralMove = /(37|39)/.test(evt.keyCode);\n                    var count = 2 + showSeconds * 1 + showAM * 1;\n\n                    // Navigate indexes (left, right)\n                    if (lateralMove) {\n                        if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n                        else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n                    }\n\n                    // Update values (up, down)\n                    var selectRange = [0, hoursLength];\n                    var incr = 0;\n                    if (evt.keyCode === 38) incr = -1;\n                    if (evt.keyCode === 40) incr = +1;\n                    var isSeconds = selectedIndex === 2 && showSeconds;\n                    var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n                    if (selectedIndex === 0) {\n                        newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n                        // re-calculate hours length because we have changed hours value\n                        hoursLength = formatDate(newDate, hoursFormat).length;\n                        selectRange = [0, hoursLength];\n                    } else if (selectedIndex === 1) {\n                        newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n                        // re-calculate minutes length because we have changes minutes value\n                        minutesLength = formatDate(newDate, minutesFormat).length;\n                        selectRange = [hoursLength + sepLength, minutesLength];\n                    } else if (isSeconds) {\n                        newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n                        // re-calculate seconds length because we have changes seconds value\n                        secondsLength = formatDate(newDate, secondsFormat).length;\n                        selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n                    } else if (isMeridian) {\n                        if (!lateralMove) $timepicker.switchMeridian();\n                        selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n                    }\n                    $timepicker.select(newDate, selectedIndex, true);\n                    createSelection(selectRange[0], selectRange[1]);\n                    parentScope.$digest();\n                };\n\n                // Private\n\n                function createSelection(start, length) {\n                    var end = start + length;\n                    if (element[0].createTextRange) {\n                        var selRange = element[0].createTextRange();\n                        selRange.collapse(true);\n                        selRange.moveStart('character', start);\n                        selRange.moveEnd('character', end);\n                        selRange.select();\n                    } else if (element[0].setSelectionRange) {\n                        element[0].setSelectionRange(start, end);\n                    } else if (angular.isUndefined(element[0].selectionStart)) {\n                        element[0].selectionStart = start;\n                        element[0].selectionEnd = end;\n                    }\n                }\n\n                function focusElement() {\n                    element[0].focus();\n                }\n\n                // Overrides\n\n                var _init = $timepicker.init;\n                $timepicker.init = function () {\n                    if (isNative && options.useNative) {\n                        element.prop('type', 'time');\n                        element.css('-webkit-appearance', 'textfield');\n                        return;\n                    } else if (isTouch) {\n                        element.prop('type', 'text');\n                        element.attr('readonly', 'true');\n                        element.on('click', focusElement);\n                    }\n                    _init();\n                };\n\n                var _destroy = $timepicker.destroy;\n                $timepicker.destroy = function () {\n                    if (isNative && options.useNative) {\n                        element.off('click', focusElement);\n                    }\n                    _destroy();\n                };\n\n                var _show = $timepicker.show;\n                $timepicker.show = function () {\n                    _show();\n                    // use timeout to hookup the events to prevent\n                    // event bubbling from being processed imediately.\n                    $timeout(function () {\n                        $timepicker.$element && $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n                        if (options.keyboard) {\n                            element && element.on('keydown', $timepicker.$onKeyDown);\n                        }\n                    }, 0, false);\n                };\n\n                var _hide = $timepicker.hide;\n                $timepicker.hide = function (blur) {\n                    if (!$timepicker.$isShown) return;\n                    $timepicker.$element && $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n                    if (options.keyboard) {\n                        element && element.off('keydown', $timepicker.$onKeyDown);\n                    }\n                    _hide(blur);\n                };\n\n                return $timepicker;\n\n            }\n\n            timepickerFactory.defaults = defaults;\n            return timepickerFactory;\n\n        };\n\n    })\n\n\n    .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n        var defaults = $timepicker.defaults;\n        var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n        var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n        return {\n            restrict: 'EAC',\n            require: 'ngModel',\n            link: function postLink(scope, element, attr, controller) {\n\n                // Directive options\n                var options = {scope: scope, controller: controller};\n                angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n                    if (angular.isDefined(attr[key])) options[key] = attr[key];\n                });\n\n                // use string regex match boolean attr falsy values, leave truthy values be\n                var falseValueRegExp = /^(false|0|)$/i;\n                angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n                        options[key] = false;\n                });\n\n                // Visibility binding support\n                attr.bsShow && scope.$watch(attr.bsShow, function (newValue, oldValue) {\n                    if (!timepicker || !angular.isDefined(newValue)) return;\n                    if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n                    newValue === true ? timepicker.show() : timepicker.hide();\n                });\n\n                // Initialize timepicker\n                if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n                var timepicker = $timepicker(element, controller, options);\n                options = timepicker.$options;\n\n                var lang = options.lang;\n                var formatDate = function (date, format, timezone) {\n                    return $dateFormatter.formatDate(date, format, lang, timezone);\n                };\n\n                // Initialize parser\n                var dateParser = $dateParser({format: options.timeFormat, lang: lang});\n\n                // Observe attributes for changes\n                angular.forEach(['minTime', 'maxTime'], function (key) {\n                    // console.warn('attr.$observe(%s)', key, attr[key]);\n                    angular.isDefined(attr[key]) && attr.$observe(key, function (newValue) {\n                        timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n                        !isNaN(timepicker.$options[key]) && timepicker.$build();\n                        validateAgainstMinMaxTime(controller.$dateValue);\n                    });\n                });\n\n                // Watch model for changes\n                scope.$watch(attr.ngModel, function (newValue, oldValue) {\n                    // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n                    timepicker.update(controller.$dateValue);\n                }, true);\n\n                function validateAgainstMinMaxTime(parsedTime) {\n                    if (!angular.isDate(parsedTime)) return;\n                    var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n                    var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n                    var isValid = isMinValid && isMaxValid;\n                    controller.$setValidity('date', isValid);\n                    controller.$setValidity('min', isMinValid);\n                    controller.$setValidity('max', isMaxValid);\n                    // Only update the model when we have a valid date\n                    if (!isValid) {\n                        return;\n                    }\n                    controller.$dateValue = parsedTime;\n                }\n\n                // viewValue -> $parsers -> modelValue\n                controller.$parsers.unshift(function (viewValue) {\n                    // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n                    var date;\n                    // Null values should correctly reset the model value & validity\n                    if (!viewValue) {\n                        // BREAKING CHANGE:\n                        // return null (not undefined) when input value is empty, so angularjs 1.3\n                        // ngModelController can go ahead and run validators, like ngRequired\n                        controller.$setValidity('date', true);\n                        return null;\n                    }\n                    var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n                    if (!parsedTime || isNaN(parsedTime.getTime())) {\n                        controller.$setValidity('date', false);\n                        // return undefined, causes ngModelController to\n                        // invalidate model value\n                        return;\n                    } else {\n                        validateAgainstMinMaxTime(parsedTime);\n                    }\n\n                    if (options.timeType === 'string') {\n                        date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n                        return formatDate(date, options.modelTimeFormat || options.timeFormat);\n                    }\n                    date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n                    if (options.timeType === 'number') {\n                        return date.getTime();\n                    } else if (options.timeType === 'unix') {\n                        return date.getTime() / 1000;\n                    } else if (options.timeType === 'iso') {\n                        return date.toISOString();\n                    } else {\n                        return new Date(date);\n                    }\n                });\n\n                // modelValue -> $formatters -> viewValue\n                controller.$formatters.push(function (modelValue) {\n                    // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n                    var date;\n                    if (angular.isUndefined(modelValue) || modelValue === null) {\n                        date = NaN;\n                    } else if (angular.isDate(modelValue)) {\n                        date = modelValue;\n                    } else if (options.timeType === 'string') {\n                        date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n                    } else if (options.timeType === 'unix') {\n                        date = new Date(modelValue * 1000);\n                    } else {\n                        date = new Date(modelValue);\n                    }\n                    // Setup default value?\n                    // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n                    controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n                    return getTimeFormattedString();\n                });\n\n                // viewValue -> element\n                controller.$render = function () {\n                    // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n                    element.val(getTimeFormattedString());\n                };\n\n                function getTimeFormattedString() {\n                    return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n                }\n\n                // Garbage collection\n                scope.$on('$destroy', function () {\n                    if (timepicker) timepicker.destroy();\n                    options = null;\n                    timepicker = null;\n                });\n\n            }\n        };\n\n    });\n",
    "'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n    .provider('$bsTooltip', function () {\n\n        var defaults = this.defaults = {\n            animation: 'am-fade',\n            customClass: '',\n            prefixClass: 'tooltip',\n            prefixEvent: 'tooltip',\n            container: false,\n            target: false,\n            placement: 'top',\n            template: 'template/datetimepicker/tooltip.tpl.html',\n            contentTemplate: false,\n            trigger: 'hover focus',\n            keyboard: false,\n            html: false,\n            show: false,\n            title: '',\n            type: '',\n            delay: 0,\n            autoClose: false,\n            bsEnabled: true,\n            viewport: {\n                selector: 'body',\n                padding: 0\n            }\n        };\n\n        this.$get = function ($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n            var trim = String.prototype.trim;\n            var isTouch = 'createTouch' in $window.document;\n            var htmlReplaceRegExp = /ng-bind=\"/ig;\n            var $body = angular.element($window.document);\n\n            function TooltipFactory(element, config) {\n\n                var $tooltip = {};\n\n                // Common vars\n                var nodeName = element[0].nodeName.toLowerCase();\n                var options = $tooltip.$options = angular.extend({}, defaults, config);\n                $tooltip.$promise = fetchTemplate(options.template);\n                var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n                if (options.delay && angular.isString(options.delay)) {\n                    var split = options.delay.split(',').map(parseFloat);\n                    options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n                }\n\n                // store $id to identify the triggering element in events\n                // give priority to options.id, otherwise, try to use\n                // element id if defined\n                $tooltip.$id = options.id || element.attr('id') || '';\n\n                // Support scope as string options\n                if (options.title) {\n                    scope.title = $sce.trustAsHtml(options.title);\n                }\n\n                // Provide scope helpers\n                scope.$setEnabled = function (isEnabled) {\n                    scope.$$postDigest(function () {\n                        $tooltip.setEnabled(isEnabled);\n                    });\n                };\n                scope.$hide = function () {\n                    scope.$$postDigest(function () {\n                        $tooltip.hide();\n                    });\n                };\n                scope.$show = function () {\n                    scope.$$postDigest(function () {\n                        $tooltip.show();\n                    });\n                };\n                scope.$toggle = function () {\n                    scope.$$postDigest(function () {\n                        $tooltip.toggle();\n                    });\n                };\n                // Publish isShown as a protected var on scope\n                $tooltip.$isShown = scope.$isShown = false;\n\n                // Private vars\n                var timeout, hoverState;\n\n                // Support contentTemplate option\n                if (options.contentTemplate) {\n                    $tooltip.$promise = $tooltip.$promise.then(function (template) {\n                        var templateEl = angular.element(template);\n                        return fetchTemplate(options.contentTemplate)\n                            .then(function (contentTemplate) {\n                                var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n                                if (!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n                                contentEl.removeAttr('ng-bind').html(contentTemplate);\n                                return templateEl[0].outerHTML;\n                            });\n                    });\n                }\n\n                // Fetch, compile then initialize tooltip\n                var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n                $tooltip.$promise.then(function (template) {\n                    if (angular.isObject(template)) template = template.data;\n                    if (options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n                    template = trim.apply(template);\n                    tipTemplate = template;\n                    tipLinker = $compile(template);\n                    $tooltip.init();\n                });\n\n                $tooltip.init = function () {\n\n                    // Options: delay\n                    if (options.delay && angular.isNumber(options.delay)) {\n                        options.delay = {\n                            show: options.delay,\n                            hide: options.delay\n                        };\n                    }\n\n                    // Replace trigger on touch devices ?\n                    // if(isTouch && options.trigger === defaults.trigger) {\n                    //   options.trigger.replace(/hover/g, 'click');\n                    // }\n\n                    // Options : container\n                    if (options.container === 'self') {\n                        tipContainer = element;\n                    } else if (angular.isElement(options.container)) {\n                        tipContainer = options.container;\n                    } else if (options.container) {\n                        tipContainer = findElement(options.container);\n                    }\n\n                    // Options: trigger\n                    bindTriggerEvents();\n\n                    // Options: target\n                    if (options.target) {\n                        options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n                    }\n\n                    // Options: show\n                    if (options.show) {\n                        scope.$$postDigest(function () {\n                            options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n                        });\n                    }\n\n                };\n\n                $tooltip.destroy = function () {\n\n                    // Unbind events\n                    unbindTriggerEvents();\n\n                    // Remove element\n                    destroyTipElement();\n\n                    // Destroy scope\n                    scope.$destroy();\n\n                };\n\n                $tooltip.enter = function () {\n\n                    clearTimeout(timeout);\n                    hoverState = 'in';\n                    if (!options.delay || !options.delay.show) {\n                        return $tooltip.show();\n                    }\n\n                    timeout = setTimeout(function () {\n                        if (hoverState === 'in') $tooltip.show();\n                    }, options.delay.show);\n\n                };\n\n                $tooltip.show = function () {\n                    if (!options.bsEnabled || $tooltip.$isShown) return;\n\n                    scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n                    var parent, after;\n                    if (options.container) {\n                        parent = tipContainer;\n                        if (tipContainer[0].lastChild) {\n                            after = angular.element(tipContainer[0].lastChild);\n                        } else {\n                            after = null;\n                        }\n                    } else {\n                        parent = null;\n                        after = element;\n                    }\n\n\n                    // Hide any existing tipElement\n                    if (tipElement) destroyTipElement();\n                    // Fetch a cloned element linked from template\n                    tipScope = $tooltip.$scope.$new();\n                    tipElement = $tooltip.$element = tipLinker(tipScope, function (clonedElement, scope) {\n                    });\n\n                    // Set the initial positioning.  Make the tooltip invisible\n                    // so IE doesn't try to focus on it off screen.\n                    tipElement.css({\n                        top: '-9999px',\n                        left: '-9999px',\n                        right: 'auto',\n                        display: 'block',\n                        visibility: 'hidden'\n                    });\n\n                    // Options: animation\n                    if (options.animation) tipElement.addClass(options.animation);\n                    // Options: type\n                    if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n                    // Options: custom classes\n                    if (options.customClass) tipElement.addClass(options.customClass);\n\n                    // Append the element, without any animations.  If we append\n                    // using $animate.enter, some of the animations cause the placement\n                    // to be off due to the transforms.\n                    after ? after.after(tipElement) : parent.prepend(tipElement);\n\n                    $tooltip.$isShown = scope.$isShown = true;\n                    safeDigest(scope);\n\n                    // Now, apply placement\n                    $tooltip.$applyPlacement();\n\n                    // Once placed, animate it.\n                    // Support v1.2+ $animate\n                    // https://github.com/angular/angular.js/issues/11713\n                    if (angular.version.minor <= 2) {\n                        $animate.enter(tipElement, parent, after, enterAnimateCallback);\n                    } else {\n                        $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n                    }\n                    safeDigest(scope);\n\n                    $$rAF(function () {\n                        // Once the tooltip is placed and the animation starts, make the tooltip visible\n                        if (tipElement) tipElement.css({visibility: 'visible'});\n                    });\n\n                    // Bind events\n                    if (options.keyboard) {\n                        if (options.trigger !== 'focus') {\n                            $tooltip.focus();\n                        }\n                        bindKeyboardEvents();\n                    }\n\n                    if (options.autoClose) {\n                        bindAutoCloseEvents();\n                    }\n\n                };\n\n                function enterAnimateCallback() {\n                    scope.$emit(options.prefixEvent + '.show', $tooltip);\n                }\n\n                $tooltip.leave = function () {\n\n                    clearTimeout(timeout);\n                    hoverState = 'out';\n                    if (!options.delay || !options.delay.hide) {\n                        return $tooltip.hide();\n                    }\n                    timeout = setTimeout(function () {\n                        if (hoverState === 'out') {\n                            $tooltip.hide();\n                        }\n                    }, options.delay.hide);\n\n                };\n\n                var _blur;\n                var _tipToHide;\n                $tooltip.hide = function (blur) {\n\n                    if (!$tooltip.$isShown) return;\n                    scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n                    // store blur value for leaveAnimateCallback to use\n                    _blur = blur;\n\n                    // store current tipElement reference to use\n                    // in leaveAnimateCallback\n                    _tipToHide = tipElement;\n\n                    // Support v1.2+ $animate\n                    // https://github.com/angular/angular.js/issues/11713\n                    if (angular.version.minor <= 2) {\n                        $animate.leave(tipElement, leaveAnimateCallback);\n                    } else {\n                        $animate.leave(tipElement).then(leaveAnimateCallback);\n                    }\n\n                    $tooltip.$isShown = scope.$isShown = false;\n                    safeDigest(scope);\n\n                    // Unbind events\n                    if (options.keyboard && tipElement !== null) {\n                        unbindKeyboardEvents();\n                    }\n\n                    if (options.autoClose && tipElement !== null) {\n                        unbindAutoCloseEvents();\n                    }\n                };\n\n                function leaveAnimateCallback() {\n                    scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n                    // check if current tipElement still references\n                    // the same element when hide was called\n                    if (tipElement === _tipToHide) {\n                        // Allow to blur the input when hidden, like when pressing enter key\n                        if (_blur && options.trigger === 'focus') {\n                            return element[0].blur();\n                        }\n\n                        // clean up child scopes\n                        destroyTipElement();\n                    }\n                }\n\n                $tooltip.toggle = function () {\n                    $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n                };\n\n                $tooltip.focus = function () {\n                    tipElement[0].focus();\n                };\n\n                $tooltip.setEnabled = function (isEnabled) {\n                    options.bsEnabled = isEnabled;\n                };\n\n                $tooltip.setViewport = function (viewport) {\n                    options.viewport = viewport;\n                };\n\n                // Protected methods\n\n                $tooltip.$applyPlacement = function () {\n                    if (!tipElement) return;\n\n                    // Determine if we're doing an auto or normal placement\n                    var placement = options.placement,\n                        autoToken = /\\s?auto?\\s?/i,\n                        autoPlace = autoToken.test(placement);\n\n                    if (autoPlace) {\n                        placement = placement.replace(autoToken, '') || defaults.placement;\n                    }\n\n                    // Need to add the position class before we get\n                    // the offsets\n                    tipElement.addClass(options.placement);\n\n                    // Get the position of the target element\n                    // and the height and width of the tooltip so we can center it.\n                    var elementPosition = getPosition(),\n                        tipWidth = tipElement.prop('offsetWidth'),\n                        tipHeight = tipElement.prop('offsetHeight');\n\n                    // If we're auto placing, we need to check the positioning\n                    if (autoPlace) {\n                        var originalPlacement = placement;\n                        var container = options.container ? findElement(options.container) : element.parent();\n                        var containerPosition = getPosition(container);\n\n                        // Determine if the vertical placement\n                        if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n                            placement = originalPlacement.replace('bottom', 'top');\n                        } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n                            placement = originalPlacement.replace('top', 'bottom');\n                        }\n\n                        // Determine the horizontal placement\n                        // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n                        // and flow in the opposite direction of their placement.\n                        if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                            elementPosition.right + tipWidth > containerPosition.width) {\n\n                            placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n                        } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                            elementPosition.left - tipWidth < containerPosition.left) {\n\n                            placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n                        }\n\n                        tipElement.removeClass(originalPlacement).addClass(placement);\n                    }\n\n                    // Get the tooltip's top and left coordinates to center it with this directive.\n                    var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n                    applyPlacement(tipPosition, placement);\n                };\n\n                $tooltip.$onKeyUp = function (evt) {\n                    if (evt.which === 27 && $tooltip.$isShown) {\n                        $tooltip.hide();\n                        evt.stopPropagation();\n                    }\n                };\n\n                $tooltip.$onFocusKeyUp = function (evt) {\n                    if (evt.which === 27) {\n                        element[0].blur();\n                        evt.stopPropagation();\n                    }\n                };\n\n                $tooltip.$onFocusElementMouseDown = function (evt) {\n                    evt.preventDefault();\n                    evt.stopPropagation();\n                    // Some browsers do not auto-focus buttons (eg. Safari)\n                    $tooltip.$isShown ? element[0].blur() : element[0].focus();\n                };\n\n                // bind/unbind events\n                function bindTriggerEvents() {\n                    var triggers = options.trigger.split(' ');\n                    angular.forEach(triggers, function (trigger) {\n                        if (trigger === 'click') {\n                            element.on('click', $tooltip.toggle);\n                        } else if (trigger !== 'manual') {\n                            element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n                            element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n                            nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n                        }\n                    });\n                }\n\n                function unbindTriggerEvents() {\n                    var triggers = options.trigger.split(' ');\n                    for (var i = triggers.length; i--;) {\n                        var trigger = triggers[i];\n                        if (trigger === 'click') {\n                            element.off('click', $tooltip.toggle);\n                        } else if (trigger !== 'manual') {\n                            element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n                            element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n                            nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n                        }\n                    }\n                }\n\n                function bindKeyboardEvents() {\n                    if (options.trigger !== 'focus') {\n                        tipElement.on('keyup', $tooltip.$onKeyUp);\n                    } else {\n                        element.on('keyup', $tooltip.$onFocusKeyUp);\n                    }\n                }\n\n                function unbindKeyboardEvents() {\n                    if (options.trigger !== 'focus') {\n                        tipElement.off('keyup', $tooltip.$onKeyUp);\n                    } else {\n                        element.off('keyup', $tooltip.$onFocusKeyUp);\n                    }\n                }\n\n                var _autoCloseEventsBinded = false;\n\n                function bindAutoCloseEvents() {\n                    // use timeout to hookup the events to prevent\n                    // event bubbling from being processed imediately.\n                    $timeout(function () {\n                        // Stop propagation when clicking inside tooltip\n                        tipElement.on('click', stopEventPropagation);\n\n                        // Hide when clicking outside tooltip\n                        $body.on('click', $tooltip.hide);\n\n                        _autoCloseEventsBinded = true;\n                    }, 0, false);\n                }\n\n                function unbindAutoCloseEvents() {\n                    if (_autoCloseEventsBinded) {\n                        tipElement.off('click', stopEventPropagation);\n                        $body.off('click', $tooltip.hide);\n                        _autoCloseEventsBinded = false;\n                    }\n                }\n\n                function stopEventPropagation(event) {\n                    event.stopPropagation();\n                }\n\n                // Private methods\n\n                function getPosition($element) {\n                    $element = $element || (options.target || element);\n\n                    var el = $element[0],\n                        isBody = el.tagName === 'BODY';\n\n                    var elRect = el.getBoundingClientRect();\n                    var rect = {};\n\n                    // IE8 has issues with angular.extend and using elRect directly.\n                    // By coping the values of elRect into a new object, we can continue to use extend\n                    for (var p in elRect) {\n                        // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n                        rect[p] = elRect[p];\n                    }\n\n                    if (rect.width === null) {\n                        // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n                        rect = angular.extend({}, rect, {\n                            width: elRect.right - elRect.left,\n                            height: elRect.bottom - elRect.top\n                        });\n                    }\n                    var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el),\n                        scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0},\n                        outerDims = isBody ? {\n                            width: document.documentElement.clientWidth,\n                            height: $window.innerHeight\n                        } : null;\n\n                    return angular.extend({}, rect, scroll, outerDims, elOffset);\n                }\n\n                function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n                    var offset;\n                    var split = placement.split('-');\n\n                    switch (split[0]) {\n                        case 'right':\n                            offset = {\n                                top: position.top + position.height / 2 - actualHeight / 2,\n                                left: position.left + position.width\n                            };\n                            break;\n                        case 'bottom':\n                            offset = {\n                                top: position.top + position.height,\n                                left: position.left + position.width / 2 - actualWidth / 2\n                            };\n                            break;\n                        case 'left':\n                            offset = {\n                                top: position.top + position.height / 2 - actualHeight / 2,\n                                left: position.left - actualWidth\n                            };\n                            break;\n                        default:\n                            offset = {\n                                top: position.top - actualHeight,\n                                left: position.left + position.width / 2 - actualWidth / 2\n                            };\n                            break;\n                    }\n\n                    if (!split[1]) {\n                        return offset;\n                    }\n\n                    // Add support for corners @todo css\n                    if (split[0] === 'top' || split[0] === 'bottom') {\n                        switch (split[1]) {\n                            case 'left':\n                                offset.left = position.left;\n                                break;\n                            case 'right':\n                                offset.left = position.left + position.width - actualWidth;\n                        }\n                    } else if (split[0] === 'left' || split[0] === 'right') {\n                        switch (split[1]) {\n                            case 'top':\n                                offset.top = position.top - actualHeight;\n                                break;\n                            case 'bottom':\n                                offset.top = position.top + position.height;\n                        }\n                    }\n\n                    return offset;\n                }\n\n                function applyPlacement(offset, placement) {\n                    var tip = tipElement[0],\n                        width = tip.offsetWidth,\n                        height = tip.offsetHeight;\n\n                    // manually read margins because getBoundingClientRect includes difference\n                    var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n                        marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n                    // we must check for NaN for ie 8/9\n                    if (isNaN(marginTop)) marginTop = 0;\n                    if (isNaN(marginLeft)) marginLeft = 0;\n\n                    offset.top = offset.top + marginTop;\n                    offset.left = offset.left + marginLeft;\n\n                    // dimensions setOffset doesn't round pixel values\n                    // so we use setOffset directly with our own function\n                    dimensions.setOffset(tip, angular.extend({\n                        using: function (props) {\n                            tipElement.css({\n                                top: Math.round(props.top) + 'px',\n                                left: Math.round(props.left) + 'px',\n                                right: ''\n                            });\n                        }\n                    }, offset), 0);\n\n                    // check to see if placing tip in new offset caused the tip to resize itself\n                    var actualWidth = tip.offsetWidth,\n                        actualHeight = tip.offsetHeight;\n\n                    if (placement === 'top' && actualHeight !== height) {\n                        offset.top = offset.top + height - actualHeight;\n                    }\n\n                    // If it's an exotic placement, exit now instead of\n                    // applying a delta and changing the arrow\n                    if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n                    var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n                    if (delta.left) {\n                        offset.left += delta.left;\n                    } else {\n                        offset.top += delta.top;\n                    }\n\n                    dimensions.setOffset(tip, offset);\n\n                    if (/top|right|bottom|left/.test(placement)) {\n                        var isVertical = /top|bottom/.test(placement),\n                            arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                            arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n                        replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n                    }\n                }\n\n                function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n                    var delta = {top: 0, left: 0},\n                        $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n                    if (!$viewport) {\n                        return delta;\n                    }\n\n                    var viewportPadding = options.viewport && options.viewport.padding || 0,\n                        viewportDimensions = getPosition($viewport);\n\n                    if (/right|left/.test(placement)) {\n                        var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll,\n                            bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n                        if (topEdgeOffset < viewportDimensions.top) { // top overflow\n                            delta.top = viewportDimensions.top - topEdgeOffset;\n                        } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n                            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n                        }\n                    } else {\n                        var leftEdgeOffset = position.left - viewportPadding,\n                            rightEdgeOffset = position.left + viewportPadding + actualWidth;\n                        if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n                            delta.left = viewportDimensions.left - leftEdgeOffset;\n                        } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n                            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n                        }\n                    }\n\n                    return delta;\n                }\n\n                function replaceArrow(delta, dimension, isHorizontal) {\n                    var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n                    $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                        .css(isHorizontal ? 'top' : 'left', '');\n                }\n\n                function destroyTipElement() {\n                    // Cancel pending callbacks\n                    clearTimeout(timeout);\n\n                    if ($tooltip.$isShown && tipElement !== null) {\n                        if (options.autoClose) {\n                            unbindAutoCloseEvents();\n                        }\n\n                        if (options.keyboard) {\n                            unbindKeyboardEvents();\n                        }\n                    }\n\n                    if (tipScope) {\n                        tipScope.$destroy();\n                        tipScope = null;\n                    }\n\n                    if (tipElement) {\n                        tipElement.remove();\n                        tipElement = $tooltip.$element = null;\n                    }\n                }\n\n                return $tooltip;\n\n            }\n\n            // Helper functions\n\n            function safeDigest(scope) {\n                scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n            }\n\n            function findElement(query, element) {\n                return angular.element((element || document).querySelectorAll(query));\n            }\n\n            var fetchPromises = {};\n\n            function fetchTemplate(template) {\n                if (fetchPromises[template]) return fetchPromises[template];\n                return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function (res) {\n                    return res.data;\n                }));\n            }\n\n            return TooltipFactory;\n\n        };\n\n    })\n\n    .directive('bsTooltip', function ($window, $location, $sce, $tooltip, $$rAF) {\n\n        return {\n            restrict: 'EAC',\n            scope: true,\n            link: function postLink(scope, element, attr, transclusion) {\n\n                // Directive options\n                var options = {scope: scope};\n                angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n                    if (angular.isDefined(attr[key])) options[key] = attr[key];\n                });\n\n                // use string regex match boolean attr falsy values, leave truthy values be\n                var falseValueRegExp = /^(false|0|)$/i;\n                angular.forEach(['html', 'container'], function (key) {\n                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n                        options[key] = false;\n                });\n\n                // should not parse target attribute (anchor tag), only data-target #1454\n                var dataTarget = element.attr('data-target');\n                if (angular.isDefined(dataTarget)) {\n                    if (falseValueRegExp.test(dataTarget))\n                        options.target = false;\n                    else\n                        options.target = dataTarget;\n                }\n\n                // overwrite inherited title value when no value specified\n                // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n                if (!scope.hasOwnProperty('title')) {\n                    scope.title = '';\n                }\n\n                // Observe scope attributes for change\n                attr.$observe('title', function (newValue) {\n                    if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n                        var oldValue = scope.title;\n                        scope.title = $sce.trustAsHtml(newValue);\n                        angular.isDefined(oldValue) && $$rAF(function () {\n                            tooltip && tooltip.$applyPlacement();\n                        });\n                    }\n                });\n\n                // Support scope as an object\n                attr.bsTooltip && scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n                    if (angular.isObject(newValue)) {\n                        angular.extend(scope, newValue);\n                    } else {\n                        scope.title = newValue;\n                    }\n                    angular.isDefined(oldValue) && $$rAF(function () {\n                        tooltip && tooltip.$applyPlacement();\n                    });\n                }, true);\n\n                // Visibility binding support\n                attr.bsShow && scope.$watch(attr.bsShow, function (newValue, oldValue) {\n                    if (!tooltip || !angular.isDefined(newValue)) return;\n                    if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n                    newValue === true ? tooltip.show() : tooltip.hide();\n                });\n\n                // Enabled binding support\n                attr.bsEnabled && scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n                    // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n                    if (!tooltip || !angular.isDefined(newValue)) return;\n                    if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n                    newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n                });\n\n                // Viewport support\n                attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n                    if (!tooltip || !angular.isDefined(newValue)) return;\n                    tooltip.setViewport(newValue);\n                });\n\n                // Initialize popover\n                var tooltip = $tooltip(element, options);\n\n                // Garbage collection\n                scope.$on('$destroy', function () {\n                    if (tooltip) tooltip.destroy();\n                    options = null;\n                    tooltip = null;\n                });\n\n            }\n        };\n\n    });\n",
    "(function () {\n\n    'use strict';\n\n    angular\n        .module('ui.dialog', [\n\n            'ui.bootstrap.modal',\n            'ui.bootstrap.transition',\n            'ui.bootstrap.tpls'])\n\n        .factory('$dialog', function ($modal) {\n            var _api = {};\n            var _instance;\n            var _result;\n            var _isOpened = false;\n\n            _api.open = function (options, flag) {\n                if (_instance && flag) {\n                    _instance.close();\n                }\n                _instance = $modal.open(options);\n\n                return _instance.result;\n            };\n\n            _api.alert = function (title, message, acceptButtonLabel, cancelButtonLabel) {\n                return _api.open({\n                    backdrop: 'static',\n                    size: 'sm',\n                    template: '<div class=\"alert-dialog\" ng-escape=\"cancel()\">\\n    <div class=\"modal-header\">\\n <h4 class=\"modal-title\">{{title}}</h4>\\n    </div>\\n\\n    <div class=\"modal-body\" ng-bind-html=\"message\">\\n    </div>\\n\\n    <div class=\"modal-footer\">\\n        <button class=\"btn btn-link\" ng-class=\"acceptButtonLabel ? \\'btn-default\\':\\'btn-primary\\'\" ng-click=\"cancel()\">\\n            {{cancelButtonLabel}}\\n        </button>\\n        <button class=\"btn btn-primary\" ng-click=\"accept()\" ng-if=\"acceptButtonLabel\">{{acceptButtonLabel}}\\n        </button>\\n    </div>\\n</div>\\n',\n                    controller: function ($scope, $modalInstance) {\n                        $scope.title = title;\n                        $scope.message = message;\n                        $scope.cancelButtonLabel = cancelButtonLabel || 'Zamknij';\n                        $scope.acceptButtonLabel = acceptButtonLabel;\n\n                        $scope.cancel = function () {\n                            $modalInstance.dismiss(false);\n                        };\n\n                        $scope.accept = function () {\n                            $modalInstance.close(true);\n                        };\n                    }\n                });\n            };\n\n            return _api;\n        })\n\n        .factory('$ask', function ($dialog, $translate, $format) {\n\n            function ask(title, message) {\n                var params = Array.prototype.slice.call(arguments, 1);\n                var acceptButtonLabel = $translate('Yes');\n                var cancelButtonLabel = $translate('No');\n\n                message = $format.apply(null, params);\n                title = $translate(title);\n\n                return $dialog.alert.call(null, title, message, acceptButtonLabel, cancelButtonLabel);\n            };\n\n            return ask;\n        })\n}());\n",
    "/*\n * angular-loading-bar\n *\n * intercepts XHR requests and creates a loading bar.\n * Based on the excellent nprogress work by rstacruz (more info in readme)\n *\n * (c) 2013 Wes Cruver\n * License: MIT\n */\n\n\n(function () {\n\n    'use strict';\n\n    // Alias the loading bar for various backwards compatibilities since the project has matured:\n    angular.module('ui.loadingbar', ['ui.loadingBarInterceptor']);\n\n\n    /**\n     * loadingBarInterceptor service\n     *\n     * Registers itself as an Angular interceptor and listens for XHR requests.\n     */\n    angular.module('ui.loadingBarInterceptor', ['ui.loadingBar'])\n        .config(['$httpProvider', function ($httpProvider) {\n\n            var interceptor = ['$q', '$cacheFactory', '$timeout', '$rootScope', '$loadingBar', function ($q, $cacheFactory, $timeout, $rootScope, $loadingBar) {\n\n                /**\n                 * The total number of requests made\n                 */\n                var reqsTotal = 0;\n\n                /**\n                 * The number of requests completed (either successfully or not)\n                 */\n                var reqsCompleted = 0;\n\n                /**\n                 * The amount of time spent fetching before showing the loading bar\n                 */\n                var latencyThreshold = $loadingBar.latencyThreshold;\n\n                /**\n                 * $timeout handle for latencyThreshold\n                 */\n                var startTimeout;\n\n\n                /**\n                 * calls $loadingBar.complete() which removes the\n                 * loading bar from the DOM.\n                 */\n                function setComplete() {\n                    $timeout.cancel(startTimeout);\n                    $loadingBar.complete();\n                    reqsCompleted = 0;\n                    reqsTotal = 0;\n                }\n\n                /**\n                 * Determine if the response has already been cached\n                 * @param  {Object}  config the config option from the request\n                 * @return {Boolean} retrns true if cached, otherwise false\n                 */\n                function isCached(config) {\n                    var cache;\n                    var defaultCache = $cacheFactory.get('$http');\n                    var defaults = $httpProvider.defaults;\n\n                    // Choose the proper cache source. Borrowed from angular: $http service\n                    if ((config.cache || defaults.cache) && config.cache !== false &&\n                        (config.method === 'GET' || config.method === 'JSONP')) {\n                        cache = angular.isObject(config.cache) ? config.cache\n                            : angular.isObject(defaults.cache) ? defaults.cache\n                            : defaultCache;\n                    }\n\n                    var cached = cache !== undefined ?\n                    cache.get(config.url) !== undefined : false;\n\n                    if (config.cached !== undefined && cached !== config.cached) {\n                        return config.cached;\n                    }\n                    config.cached = cached;\n                    return cached;\n                }\n\n                return {\n                    'request': function (config) {\n                        // Check to make sure this request hasn't already been cached and that\n                        // the requester didn't explicitly ask us to ignore this request:\n                        if (!config.ignoreLoadingBar && !isCached(config)) {\n                            $rootScope.$broadcast('$loadingBar:loading', {url: config.url});\n                            if (reqsTotal === 0) {\n                                startTimeout = $timeout(function () {\n                                    $loadingBar.start();\n                                }, latencyThreshold);\n                            }\n                            reqsTotal++;\n                            $loadingBar.set(reqsCompleted / reqsTotal);\n                        }\n                        return config;\n                    },\n\n                    'response': function (response) {\n                        if (!response.config.ignoreLoadingBar && !isCached(response.config)) {\n                            reqsCompleted++;\n                            $rootScope.$broadcast('$loadingBar:loaded', {url: response.config.url});\n                            if (reqsCompleted >= reqsTotal) {\n                                setComplete();\n                            } else {\n                                $loadingBar.set(reqsCompleted / reqsTotal);\n                            }\n                        }\n                        return response;\n                    },\n\n                    'responseError': function (rejection) {\n                        if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {\n                            reqsCompleted++;\n                            $rootScope.$broadcast('$loadingBar:loaded', {url: rejection.config.url});\n                            if (reqsCompleted >= reqsTotal) {\n                                setComplete();\n                            } else {\n                                $loadingBar.set(reqsCompleted / reqsTotal);\n                            }\n                        }\n                        return $q.reject(rejection);\n                    }\n                };\n            }];\n\n            $httpProvider.interceptors.push(interceptor);\n        }]);\n\n\n    /**\n     * Loading Bar\n     *\n     * This service handles adding and removing the actual element in the DOM.\n     * Generally, best practices for DOM manipulation is to take place in a\n     * directive, but because the element itself is injected in the DOM only upon\n     * XHR requests, and it's likely needed on every view, the best option is to\n     * use a service.\n     */\n    angular.module('ui.loadingBar', [])\n        .provider('$loadingBar', function () {\n\n            this.includeSpinner = true;\n            this.includeBar = true;\n            this.latencyThreshold = 100;\n            this.startSize = 0.02;\n            this.parentSelector = 'body';\n            this.spinnerTemplate = '<div id=\"loading-bar-spinner\"><div class=\"spinner-icon\"></div></div>';\n            this.loadingBarTemplate = '<div id=\"loading-bar\"><div class=\"bar\"><div class=\"peg\"></div></div></div>';\n\n            this.$get = ['$injector', '$document', '$timeout', '$rootScope', function ($injector, $document, $timeout, $rootScope) {\n                var $animate;\n                var $parentSelector = this.parentSelector,\n                    loadingBarContainer = angular.element(this.loadingBarTemplate),\n                    loadingBar = loadingBarContainer.find('div').eq(0),\n                    spinner = angular.element(this.spinnerTemplate);\n\n                var incTimeout,\n                    completeTimeout,\n                    started = false,\n                    status = 0;\n\n                var includeSpinner = this.includeSpinner;\n                var includeBar = this.includeBar;\n                var startSize = this.startSize;\n\n                /**\n                 * Inserts the loading bar element into the dom, and sets it to 2%\n                 */\n                function _start() {\n                    if (!$animate) {\n                        $animate = $injector.get('$animate');\n                    }\n\n                    var $parent = $document.find($parentSelector).eq(0);\n                    $timeout.cancel(completeTimeout);\n\n                    // do not continually broadcast the started event:\n                    if (started) {\n                        return;\n                    }\n\n                    $rootScope.$broadcast('$loadingBar.started');\n                    started = true;\n\n                    if (includeBar) {\n                        $animate.enter(loadingBarContainer, $parent);\n                    }\n\n                    if (includeSpinner) {\n                        $animate.enter(spinner, $parent);\n                    }\n\n                    _set(startSize);\n                }\n\n                /**\n                 * Set the loading bar's width to a certain percent.\n                 *\n                 * @param n any value between 0 and 1\n                 */\n                function _set(n) {\n                    if (!started) {\n                        return;\n                    }\n                    var pct = (n * 100) + '%';\n                    loadingBar.css('width', pct);\n                    status = n;\n\n                    // increment loadingbar to give the illusion that there is always\n                    // progress but make sure to cancel the previous timeouts so we don't\n                    // have multiple incs running at the same time.\n                    $timeout.cancel(incTimeout);\n                    incTimeout = $timeout(function () {\n                        _inc();\n                    }, 250);\n                }\n\n                /**\n                 * Increments the loading bar by a random amount\n                 * but slows down as it progresses\n                 */\n                function _inc() {\n                    if (_status() >= 1) {\n                        return;\n                    }\n\n                    var rnd = 0;\n\n                    // TODO: do this mathmatically instead of through conditions\n\n                    var stat = _status();\n                    if (stat >= 0 && stat < 0.25) {\n                        // Start out between 3 - 6% increments\n                        rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;\n                    } else if (stat >= 0.25 && stat < 0.65) {\n                        // increment between 0 - 3%\n                        rnd = (Math.random() * 3) / 100;\n                    } else if (stat >= 0.65 && stat < 0.9) {\n                        // increment between 0 - 2%\n                        rnd = (Math.random() * 2) / 100;\n                    } else if (stat >= 0.9 && stat < 0.99) {\n                        // finally, increment it .5 %\n                        rnd = 0.005;\n                    } else {\n                        // after 99%, don't increment:\n                        rnd = 0;\n                    }\n\n                    var pct = _status() + rnd;\n                    _set(pct);\n                }\n\n                function _status() {\n                    return status;\n                }\n\n                function _completeAnimation() {\n                    status = 0;\n                    started = false;\n                }\n\n                function _complete() {\n                    if (!$animate) {\n                        $animate = $injector.get('$animate');\n                    }\n\n                    $rootScope.$broadcast('$loadingBar.completed');\n                    _set(1);\n\n                    $timeout.cancel(completeTimeout);\n\n                    // Attempt to aggregate any start/complete calls within 500ms:\n                    completeTimeout = $timeout(function () {\n                        var promise = $animate.leave(loadingBarContainer, _completeAnimation);\n                        if (promise && promise.then) {\n                            promise.then(_completeAnimation);\n                        }\n                        $animate.leave(spinner);\n                    }, 500);\n                }\n\n                return {\n                    start: _start,\n                    set: _set,\n                    status: _status,\n                    inc: _inc,\n                    complete: _complete,\n                    includeSpinner: this.includeSpinner,\n                    latencyThreshold: this.latencyThreshold,\n                    parentSelector: this.parentSelector,\n                    startSize: this.startSize\n                };\n\n\n            }];     //\n        });       // wtf javascript. srsly\n})();       //\n",
    "(function () {\n\n    'use strict';\n\n    angular.module('ui.multiselect', ['ng', 'ui.translate'])\n\n        .run(function ($rootScope, $translate) {\n            $rootScope.multiSelectLabels = {\n                selectAll: $translate('selectAll'),\n                selectNone: $translate('selectNone'),\n                reset: $translate('reset'),\n                search: $translate('search'),\n                nothingSelected: $translate('nothingSelected')\n            };\n        })\n\n        .directive('multiSelect', ['$sce', '$timeout', '$templateCache', function ($sce, $timeout, $templateCache) {\n            return {\n                restrict: 'AE',\n\n                scope: {\n                    // models\n                    inputModel: '=',\n                    outputModel: '=',\n\n                    // settings based on attribute\n                    isDisabled: '=',\n\n                    // callbacks\n                    onClear: '&',\n                    onClose: '&',\n                    onSearchChange: '&',\n                    onItemClick: '&',\n                    onOpen: '&',\n                    onReset: '&',\n                    onSelectAll: '&',\n                    onSelectNone: '&',\n\n                    // i18n\n                    translation: '='\n                },\n\n                /*\n                 * The rest are attributes. They don't need to be parsed / binded, so we can safely access them by value.\n                 * - buttonLabel, directiveId, helperElements, itemLabel, maxLabels, orientation, selectionMode, minSearchLength,\n                 *   tickProperty, disableProperty, groupProperty, searchProperty, maxHeight, outputProperties\n                 */\n\n                templateUrl: 'isteven-multi-select.htm',\n\n                link: function ($scope, element, attrs) {\n\n                    $scope.backUp = [];\n                    $scope.varButtonLabel = '';\n                    $scope.spacingProperty = '';\n                    $scope.indexProperty = '';\n                    $scope.orientationH = false;\n                    $scope.orientationV = true;\n                    $scope.filteredModel = [];\n                    $scope.inputLabel = {labelFilter: ''};\n                    $scope.tabIndex = 0;\n                    $scope.lang = {};\n                    $scope.helperStatus = {\n                        all: true,\n                        none: true,\n                        reset: true,\n                        filter: true\n                    };\n\n                    var\n                        prevTabIndex = 0,\n                        helperItems = [],\n                        helperItemsLength = 0,\n                        checkBoxLayer = '',\n                        scrolled = false,\n                        selectedItems = [],\n                        formElements = [],\n                        vMinSearchLength = 0,\n                        clickedItem = null\n\n                    // v3.0.0\n                    // clear button clicked\n                    $scope.clearClicked = function (e) {\n                        $scope.inputLabel.labelFilter = '';\n                        $scope.updateFilter();\n                        $scope.select('clear', e);\n                    }\n\n                    // A little hack so that AngularJS ng-repeat can loop using start and end index like a normal loop\n                    // http://stackoverflow.com/questions/16824853/way-to-ng-repeat-defined-number-of-times-instead-of-repeating-over-array\n                    $scope.numberToArray = function (num) {\n                        return new Array(num);\n                    }\n\n                    // Call this function when user type on the filter field\n                    $scope.searchChanged = function () {\n                        if ($scope.inputLabel.labelFilter.length < vMinSearchLength && $scope.inputLabel.labelFilter.length > 0) {\n                            return false;\n                        }\n                        $scope.updateFilter();\n                    }\n\n                    $scope.updateFilter = function () {\n                        // we check by looping from end of input-model\n                        $scope.filteredModel = [];\n                        var i = 0;\n\n                        if (typeof $scope.inputModel === 'undefined') {\n                            return false;\n                        }\n\n                        for (i = $scope.inputModel.length - 1; i >= 0; i--) {\n\n                            // if it's group end, we push it to filteredModel[];\n                            if (typeof $scope.inputModel[i][attrs.groupProperty] !== 'undefined' && $scope.inputModel[i][attrs.groupProperty] === false) {\n                                $scope.filteredModel.push($scope.inputModel[i]);\n                            }\n\n                            // if it's data\n                            var gotData = false;\n                            if (typeof $scope.inputModel[i][attrs.groupProperty] === 'undefined') {\n\n                                // If we set the search-key attribute, we use this loop.\n                                if (typeof attrs.searchProperty !== 'undefined' && attrs.searchProperty !== '') {\n\n                                    for (var key in $scope.inputModel[i]) {\n                                        if (\n                                            typeof $scope.inputModel[i][key] !== 'boolean'\n                                            && String($scope.inputModel[i][key]).toUpperCase().indexOf($scope.inputLabel.labelFilter.toUpperCase()) >= 0\n                                            && attrs.searchProperty.indexOf(key) > -1\n                                        ) {\n                                            gotData = true;\n                                            break;\n                                        }\n                                    }\n                                }\n                                // if there's no search-key attribute, we use this one. Much better on performance.\n                                else {\n                                    for (var key in $scope.inputModel[i]) {\n                                        if (\n                                            typeof $scope.inputModel[i][key] !== 'boolean'\n                                            && String($scope.inputModel[i][key]).toUpperCase().indexOf($scope.inputLabel.labelFilter.toUpperCase()) >= 0\n                                        ) {\n                                            gotData = true;\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                if (gotData === true) {\n                                    // push\n                                    $scope.filteredModel.push($scope.inputModel[i]);\n                                }\n                            }\n\n                            // if it's group start\n                            if (typeof $scope.inputModel[i][attrs.groupProperty] !== 'undefined' && $scope.inputModel[i][attrs.groupProperty] === true) {\n\n                                if (typeof $scope.filteredModel[$scope.filteredModel.length - 1][attrs.groupProperty] !== 'undefined'\n                                    && $scope.filteredModel[$scope.filteredModel.length - 1][attrs.groupProperty] === false) {\n                                    $scope.filteredModel.pop();\n                                }\n                                else {\n                                    $scope.filteredModel.push($scope.inputModel[i]);\n                                }\n                            }\n                        }\n\n                        $scope.filteredModel.reverse();\n\n                        $timeout(function () {\n\n                            $scope.getFormElements();\n\n                            // Callback: on filter change\n                            if ($scope.inputLabel.labelFilter.length > vMinSearchLength) {\n\n                                var filterObj = [];\n\n                                angular.forEach($scope.filteredModel, function (value, key) {\n                                    if (typeof value !== 'undefined') {\n                                        if (typeof value[attrs.groupProperty] === 'undefined') {\n                                            var tempObj = angular.copy(value);\n                                            var index = filterObj.push(tempObj);\n                                            delete filterObj[index - 1][$scope.indexProperty];\n                                            delete filterObj[index - 1][$scope.spacingProperty];\n                                        }\n                                    }\n                                });\n\n                                $scope.onSearchChange({\n                                    data: {\n                                        keyword: $scope.inputLabel.labelFilter,\n                                        result: filterObj\n                                    }\n                                });\n                            }\n                        }, 0);\n                    };\n\n                    // List all the input elements. We need this for our keyboard navigation.\n                    // This function will be called everytime the filter is updated.\n                    // Depending on the size of filtered mode, might not good for performance, but oh well..\n                    $scope.getFormElements = function () {\n                        formElements = [];\n\n                        var\n                            selectButtons = [],\n                            inputField = [],\n                            checkboxes = [],\n                            clearButton = [];\n\n                        // If available, then get select all, select none, and reset buttons\n                        if ($scope.helperStatus.all || $scope.helperStatus.none || $scope.helperStatus.reset) {\n                            selectButtons = element.children().children().next().children().children()[0].getElementsByTagName('button');\n                            // If available, then get the search box and the clear button\n                            if ($scope.helperStatus.filter) {\n                                // Get helper - search and clear button.\n                                inputField = element.children().children().next().children().children().next()[0].getElementsByTagName('input');\n                                clearButton = element.children().children().next().children().children().next()[0].getElementsByTagName('button');\n                            }\n                        }\n                        else {\n                            if ($scope.helperStatus.filter) {\n                                // Get helper - search and clear button.\n                                inputField = element.children().children().next().children().children()[0].getElementsByTagName('input');\n                                clearButton = element.children().children().next().children().children()[0].getElementsByTagName('button');\n                            }\n                        }\n\n                        // Get checkboxes\n                        if (!$scope.helperStatus.all && !$scope.helperStatus.none && !$scope.helperStatus.reset && !$scope.helperStatus.filter) {\n                            checkboxes = element.children().children().next()[0].getElementsByTagName('input');\n                        }\n                        else {\n                            checkboxes = element.children().children().next().children().next()[0].getElementsByTagName('input');\n                        }\n\n                        // Push them into global array formElements[]\n                        for (var i = 0; i < selectButtons.length; i++) {\n                            formElements.push(selectButtons[i]);\n                        }\n                        for (var i = 0; i < inputField.length; i++) {\n                            formElements.push(inputField[i]);\n                        }\n                        for (var i = 0; i < clearButton.length; i++) {\n                            formElements.push(clearButton[i]);\n                        }\n                        for (var i = 0; i < checkboxes.length; i++) {\n                            formElements.push(checkboxes[i]);\n                        }\n                    }\n\n                    // check if an item has attrs.groupProperty (be it true or false)\n                    $scope.isGroupMarker = function (item, type) {\n                        if (typeof item[attrs.groupProperty] !== 'undefined' && item[attrs.groupProperty] === type) return true;\n                        return false;\n                    }\n\n                    $scope.removeGroupEndMarker = function (item) {\n                        if (typeof item[attrs.groupProperty] !== 'undefined' && item[attrs.groupProperty] === false) return false;\n                        return true;\n                    }\n\n                    // call this function when an item is clicked\n                    $scope.syncItems = function (item, e, ng_repeat_index) {\n\n                        e.preventDefault();\n                        e.stopPropagation();\n\n                        // if the directive is globaly disabled, do nothing\n                        if (typeof attrs.disableProperty !== 'undefined' && item[attrs.disableProperty] === true) {\n                            return false;\n                        }\n\n                        // if item is disabled, do nothing\n                        if (typeof attrs.isDisabled !== 'undefined' && $scope.isDisabled === true) {\n                            return false;\n                        }\n\n                        // if end group marker is clicked, do nothing\n                        if (typeof item[attrs.groupProperty] !== 'undefined' && item[attrs.groupProperty] === false) {\n                            return false;\n                        }\n\n                        var index = $scope.filteredModel.indexOf(item);\n\n                        // if the start of group marker is clicked ( only for multiple selection! )\n                        // how it works:\n                        // - if, in a group, there are items which are not selected, then they all will be selected\n                        // - if, in a group, all items are selected, then they all will be de-selected\n                        if (typeof item[attrs.groupProperty] !== 'undefined' && item[attrs.groupProperty] === true) {\n\n                            // this is only for multiple selection, so if selection mode is single, do nothing\n                            if (typeof attrs.selectionMode !== 'undefined' && attrs.selectionMode.toUpperCase() === 'SINGLE') {\n                                return false;\n                            }\n\n                            var i, j, k;\n                            var startIndex = 0;\n                            var endIndex = $scope.filteredModel.length - 1;\n                            var tempArr = [];\n\n                            // nest level is to mark the depth of the group.\n                            // when you get into a group (start group marker), nestLevel++\n                            // when you exit a group (end group marker), nextLevel--\n                            var nestLevel = 0;\n\n                            // we loop throughout the filtered model (not whole model)\n                            for (i = index; i < $scope.filteredModel.length; i++) {\n\n                                // this break will be executed when we're done processing each group\n                                if (nestLevel === 0 && i > index) {\n                                    break;\n                                }\n\n                                if (typeof $scope.filteredModel[i][attrs.groupProperty] !== 'undefined' && $scope.filteredModel[i][attrs.groupProperty] === true) {\n\n                                    // To cater multi level grouping\n                                    if (tempArr.length === 0) {\n                                        startIndex = i + 1;\n                                    }\n                                    nestLevel = nestLevel + 1;\n                                }\n\n                                // if group end\n                                else if (typeof $scope.filteredModel[i][attrs.groupProperty] !== 'undefined' && $scope.filteredModel[i][attrs.groupProperty] === false) {\n\n                                    nestLevel = nestLevel - 1;\n\n                                    // cek if all are ticked or not\n                                    if (tempArr.length > 0 && nestLevel === 0) {\n\n                                        var allTicked = true;\n\n                                        endIndex = i;\n\n                                        for (j = 0; j < tempArr.length; j++) {\n                                            if (typeof tempArr[j][$scope.tickProperty] !== 'undefined' && tempArr[j][$scope.tickProperty] === false) {\n                                                allTicked = false;\n                                                break;\n                                            }\n                                        }\n\n                                        if (allTicked === true) {\n                                            for (j = startIndex; j <= endIndex; j++) {\n                                                if (typeof $scope.filteredModel[j][attrs.groupProperty] === 'undefined') {\n                                                    if (typeof attrs.disableProperty === 'undefined') {\n                                                        $scope.filteredModel[j][$scope.tickProperty] = false;\n                                                        // we refresh input model as well\n                                                        inputModelIndex = $scope.filteredModel[j][$scope.indexProperty];\n                                                        $scope.inputModel[inputModelIndex][$scope.tickProperty] = false;\n                                                    }\n                                                    else if ($scope.filteredModel[j][attrs.disableProperty] !== true) {\n                                                        $scope.filteredModel[j][$scope.tickProperty] = false;\n                                                        // we refresh input model as well\n                                                        inputModelIndex = $scope.filteredModel[j][$scope.indexProperty];\n                                                        $scope.inputModel[inputModelIndex][$scope.tickProperty] = false;\n                                                    }\n                                                }\n                                            }\n                                        }\n\n                                        else {\n                                            for (j = startIndex; j <= endIndex; j++) {\n                                                if (typeof $scope.filteredModel[j][attrs.groupProperty] === 'undefined') {\n                                                    if (typeof attrs.disableProperty === 'undefined') {\n                                                        $scope.filteredModel[j][$scope.tickProperty] = true;\n                                                        // we refresh input model as well\n                                                        inputModelIndex = $scope.filteredModel[j][$scope.indexProperty];\n                                                        $scope.inputModel[inputModelIndex][$scope.tickProperty] = true;\n\n                                                    }\n                                                    else if ($scope.filteredModel[j][attrs.disableProperty] !== true) {\n                                                        $scope.filteredModel[j][$scope.tickProperty] = true;\n                                                        // we refresh input model as well\n                                                        inputModelIndex = $scope.filteredModel[j][$scope.indexProperty];\n                                                        $scope.inputModel[inputModelIndex][$scope.tickProperty] = true;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n\n                                // if data\n                                else {\n                                    tempArr.push($scope.filteredModel[i]);\n                                }\n                            }\n                        }\n\n                        // if an item (not group marker) is clicked\n                        else {\n\n                            // If it's single selection mode\n                            if (typeof attrs.selectionMode !== 'undefined' && attrs.selectionMode.toUpperCase() === 'SINGLE') {\n\n                                // first, set everything to false\n                                for (i = 0; i < $scope.filteredModel.length; i++) {\n                                    $scope.filteredModel[i][$scope.tickProperty] = false;\n                                }\n                                for (i = 0; i < $scope.inputModel.length; i++) {\n                                    $scope.inputModel[i][$scope.tickProperty] = false;\n                                }\n\n                                // then set the clicked item to true\n                                $scope.filteredModel[index][$scope.tickProperty] = true;\n                            }\n\n                            // Multiple\n                            else {\n                                $scope.filteredModel[index][$scope.tickProperty] = !$scope.filteredModel[index][$scope.tickProperty];\n                            }\n\n                            // we refresh input model as well\n                            var inputModelIndex = $scope.filteredModel[index][$scope.indexProperty];\n                            $scope.inputModel[inputModelIndex][$scope.tickProperty] = $scope.filteredModel[index][$scope.tickProperty];\n                        }\n\n                        // we execute the callback function here\n                        clickedItem = angular.copy(item);\n                        if (clickedItem !== null) {\n                            $timeout(function () {\n                                delete clickedItem[$scope.indexProperty];\n                                delete clickedItem[$scope.spacingProperty];\n                                $scope.onItemClick({data: clickedItem});\n                                clickedItem = null;\n                            }, 0);\n                        }\n\n                        $scope.refreshOutputModel();\n                        $scope.refreshButton();\n\n                        // We update the index here\n                        prevTabIndex = $scope.tabIndex;\n                        $scope.tabIndex = ng_repeat_index + helperItemsLength;\n\n                        // Set focus on the hidden checkbox\n                        e.target.focus();\n\n                        // set & remove CSS style\n                        $scope.removeFocusStyle(prevTabIndex);\n                        $scope.setFocusStyle($scope.tabIndex);\n\n                        if (typeof attrs.selectionMode !== 'undefined' && attrs.selectionMode.toUpperCase() === 'SINGLE') {\n                            // on single selection mode, we then hide the checkbox layer\n                            $scope.toggleCheckboxes(e);\n                        }\n                    }\n\n                    // update $scope.outputModel\n                    $scope.refreshOutputModel = function () {\n\n                        $scope.outputModel = [];\n                        var\n                            outputProps = [],\n                            tempObj = {};\n\n                        // v4.0.0\n                        if (typeof attrs.outputProperties !== 'undefined') {\n                            outputProps = attrs.outputProperties.split(' ');\n                            angular.forEach($scope.inputModel, function (value, key) {\n                                if (\n                                    typeof value !== 'undefined'\n                                    && typeof value[attrs.groupProperty] === 'undefined'\n                                    && value[$scope.tickProperty] === true\n                                ) {\n                                    tempObj = {};\n                                    angular.forEach(value, function (value1, key1) {\n                                        if (outputProps.indexOf(key1) > -1) {\n                                            tempObj[key1] = value1;\n                                        }\n                                    });\n                                    var index = $scope.outputModel.push(tempObj);\n                                    delete $scope.outputModel[index - 1][$scope.indexProperty];\n                                    delete $scope.outputModel[index - 1][$scope.spacingProperty];\n                                }\n                            });\n                        }\n                        else {\n                            angular.forEach($scope.inputModel, function (value, key) {\n                                if (\n                                    typeof value !== 'undefined'\n                                    && typeof value[attrs.groupProperty] === 'undefined'\n                                    && value[$scope.tickProperty] === true\n                                ) {\n                                    var temp = angular.copy(value);\n                                    var index = $scope.outputModel.push(temp);\n                                    delete $scope.outputModel[index - 1][$scope.indexProperty];\n                                    delete $scope.outputModel[index - 1][$scope.spacingProperty];\n                                }\n                            });\n                        }\n                    }\n\n                    // refresh button label\n                    $scope.refreshButton = function () {\n\n                        $scope.varButtonLabel = '';\n                        var ctr = 0;\n\n                        // refresh button label...\n                        if ($scope.outputModel.length === 0) {\n                            // https://github.com/isteven/angular-multi-select/pull/19\n                            $scope.varButtonLabel = $scope.lang.nothingSelected;\n                        }\n                        else {\n                            var tempMaxLabels = $scope.outputModel.length;\n                            if (typeof attrs.maxLabels !== 'undefined' && attrs.maxLabels !== '') {\n                                tempMaxLabels = attrs.maxLabels;\n                            }\n\n                            // if max amount of labels displayed..\n                            if ($scope.outputModel.length > tempMaxLabels) {\n                                $scope.more = true;\n                            }\n                            else {\n                                $scope.more = false;\n                            }\n\n                            angular.forEach($scope.inputModel, function (value, key) {\n                                if (typeof value !== 'undefined' && value[attrs.tickProperty] === true) {\n                                    if (ctr < tempMaxLabels) {\n                                        $scope.varButtonLabel += ( $scope.varButtonLabel.length > 0 ? '</div>, <div class=\"buttonLabel\">' : '<div class=\"buttonLabel\">') + $scope.writeLabel(value, 'buttonLabel');\n                                    }\n                                    ctr++;\n                                }\n                            });\n\n                            if ($scope.more === true) {\n                                // https://github.com/isteven/angular-multi-select/pull/16\n                                if (tempMaxLabels > 0) {\n                                    $scope.varButtonLabel += ', ... ';\n                                }\n                                $scope.varButtonLabel += '(' + $scope.outputModel.length + ')';\n                            }\n                        }\n                        $scope.varButtonLabel = $sce.trustAsHtml($scope.varButtonLabel + '<span class=\"caret\"></span>');\n                    }\n\n                    // Check if a checkbox is disabled or enabled. It will check the granular control (disableProperty) and global control (isDisabled)\n                    // Take note that the granular control has higher priority.\n                    $scope.itemIsDisabled = function (item) {\n\n                        if (typeof attrs.disableProperty !== 'undefined' && item[attrs.disableProperty] === true) {\n                            return true;\n                        }\n                        else {\n                            if ($scope.isDisabled === true) {\n                                return true;\n                            }\n                            else {\n                                return false;\n                            }\n                        }\n\n                    }\n\n                    // A simple function to parse the item label settings. Used on the buttons and checkbox labels.\n                    $scope.writeLabel = function (item, type) {\n\n                        // type is either 'itemLabel' or 'buttonLabel'\n                        var temp = attrs[type].split(' ');\n                        var label = '';\n\n                        angular.forEach(temp, function (value, key) {\n                            item[value] && ( label += '&nbsp;' + value.split('.').reduce(function (prev, current) {\n                                    return prev[current];\n                                }, item));\n                        });\n\n                        if (type.toUpperCase() === 'BUTTONLABEL') {\n                            return label;\n                        }\n                        return $sce.trustAsHtml(label);\n                    }\n\n                    // UI operations to show/hide checkboxes based on click event..\n                    $scope.toggleCheckboxes = function (e) {\n\n                        // We grab the button\n                        var clickedEl = element.children()[0];\n\n                        // Just to make sure.. had a bug where key events were recorded twice\n                        angular.element(document).off('click', $scope.externalClickListener);\n                        angular.element(document).off('keydown', $scope.keyboardListener);\n\n                        // The idea below was taken from another multi-select directive - https://github.com/amitava82/angular-multiselect\n                        // His version is awesome if you need a more simple multi-select approach.\n\n                        // close\n                        if (angular.element(checkBoxLayer).hasClass('show')) {\n\n                            angular.element(checkBoxLayer).removeClass('show');\n                            angular.element(clickedEl).removeClass('buttonClicked');\n                            angular.element(document).off('click', $scope.externalClickListener);\n                            angular.element(document).off('keydown', $scope.keyboardListener);\n\n                            // clear the focused element;\n                            $scope.removeFocusStyle($scope.tabIndex);\n                            if (typeof formElements[$scope.tabIndex] !== 'undefined') {\n                                formElements[$scope.tabIndex].blur();\n                            }\n\n                            // close callback\n                            $timeout(function () {\n                                $scope.onClose();\n                            }, 0);\n\n                            // set focus on button again\n                            element.children().children()[0].focus();\n                        }\n                        // open\n                        else {\n                            // clear filter\n                            $scope.inputLabel.labelFilter = '';\n                            $scope.updateFilter();\n\n                            helperItems = [];\n                            helperItemsLength = 0;\n\n                            angular.element(checkBoxLayer).addClass('show');\n                            angular.element(clickedEl).addClass('buttonClicked');\n\n                            // Attach change event listener on the input filter.\n                            // We need this because ng-change is apparently not an event listener.\n                            angular.element(document).on('click', $scope.externalClickListener);\n                            angular.element(document).on('keydown', $scope.keyboardListener);\n\n                            // to get the initial tab index, depending on how many helper elements we have.\n                            // priority is to always focus it on the input filter\n                            $scope.getFormElements();\n                            $scope.tabIndex = 0;\n\n                            var helperContainer = angular.element(element[0].querySelector('.helperContainer'))[0];\n\n                            if (typeof helperContainer !== 'undefined') {\n                                for (var i = 0; i < helperContainer.getElementsByTagName('BUTTON').length; i++) {\n                                    helperItems[i] = helperContainer.getElementsByTagName('BUTTON')[i];\n                                }\n                                helperItemsLength = helperItems.length + helperContainer.getElementsByTagName('INPUT').length;\n                            }\n\n                            // focus on the filter element on open.\n                            if (element[0].querySelector('.inputFilter')) {\n                                element[0].querySelector('.inputFilter').focus();\n                                $scope.tabIndex = $scope.tabIndex + helperItemsLength - 2;\n                                // blur button in vain\n                                angular.element(element).children()[0].blur();\n                            }\n                            // if there's no filter then just focus on the first checkbox item\n                            else {\n                                if (!$scope.isDisabled) {\n                                    $scope.tabIndex = $scope.tabIndex + helperItemsLength;\n                                    if ($scope.inputModel.length > 0) {\n                                        formElements[$scope.tabIndex].focus();\n                                        $scope.setFocusStyle($scope.tabIndex);\n                                        // blur button in vain\n                                        angular.element(element).children()[0].blur();\n                                    }\n                                }\n                            }\n\n                            // open callback\n                            $scope.onOpen();\n                        }\n                    }\n\n                    // handle clicks outside the button / multi select layer\n                    $scope.externalClickListener = function (e) {\n\n                        var targetsArr = element.find(e.target.tagName);\n                        for (var i = 0; i < targetsArr.length; i++) {\n                            if (e.target == targetsArr[i]) {\n                                return;\n                            }\n                        }\n\n                        angular.element(checkBoxLayer.previousSibling).removeClass('buttonClicked');\n                        angular.element(checkBoxLayer).removeClass('show');\n                        angular.element(document).off('click', $scope.externalClickListener);\n                        angular.element(document).off('keydown', $scope.keyboardListener);\n\n                        // close callback\n                        $timeout(function () {\n                            $scope.onClose();\n                        }, 0);\n\n                        // set focus on button again\n                        element.children().children()[0].focus();\n                    }\n\n                    // select All / select None / reset buttons\n                    $scope.select = function (type, e) {\n\n                        var helperIndex = helperItems.indexOf(e.target);\n                        $scope.tabIndex = helperIndex;\n\n                        switch (type.toUpperCase()) {\n                            case 'ALL':\n                                angular.forEach($scope.filteredModel, function (value, key) {\n                                    if (typeof value !== 'undefined' && value[attrs.disableProperty] !== true) {\n                                        if (typeof value[attrs.groupProperty] === 'undefined') {\n                                            value[$scope.tickProperty] = true;\n                                        }\n                                    }\n                                });\n                                $scope.refreshOutputModel();\n                                $scope.refreshButton();\n                                $scope.onSelectAll();\n                                break;\n                            case 'NONE':\n                                angular.forEach($scope.filteredModel, function (value, key) {\n                                    if (typeof value !== 'undefined' && value[attrs.disableProperty] !== true) {\n                                        if (typeof value[attrs.groupProperty] === 'undefined') {\n                                            value[$scope.tickProperty] = false;\n                                        }\n                                    }\n                                });\n                                $scope.refreshOutputModel();\n                                $scope.refreshButton();\n                                $scope.onSelectNone();\n                                break;\n                            case 'RESET':\n                                angular.forEach($scope.filteredModel, function (value, key) {\n                                    if (typeof value[attrs.groupProperty] === 'undefined' && typeof value !== 'undefined' && value[attrs.disableProperty] !== true) {\n                                        var temp = value[$scope.indexProperty];\n                                        value[$scope.tickProperty] = $scope.backUp[temp][$scope.tickProperty];\n                                    }\n                                });\n                                $scope.refreshOutputModel();\n                                $scope.refreshButton();\n                                $scope.onReset();\n                                break;\n                            case 'CLEAR':\n                                $scope.tabIndex = $scope.tabIndex + 1;\n                                $scope.onClear();\n                                break;\n                            case 'FILTER':\n                                $scope.tabIndex = helperItems.length - 1;\n                                break;\n                            default:\n                        }\n                    }\n\n                    // just to create a random variable name\n                    function genRandomString(length) {\n                        var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n                        var temp = '';\n                        for (var i = 0; i < length; i++) {\n                            temp += possible.charAt(Math.floor(Math.random() * possible.length));\n                        }\n                        return temp;\n                    }\n\n                    // count leading spaces\n                    $scope.prepareGrouping = function () {\n                        var spacing = 0;\n                        angular.forEach($scope.filteredModel, function (value, key) {\n                            value[$scope.spacingProperty] = spacing;\n                            if (value[attrs.groupProperty] === true) {\n                                spacing += 2;\n                            }\n                            else if (value[attrs.groupProperty] === false) {\n                                spacing -= 2;\n                            }\n                        });\n                    }\n\n                    // prepare original index\n                    $scope.prepareIndex = function () {\n                        var ctr = 0;\n                        angular.forEach($scope.filteredModel, function (value, key) {\n                            value[$scope.indexProperty] = ctr;\n                            ctr++;\n                        });\n                    }\n\n                    // navigate using up and down arrow\n                    $scope.keyboardListener = function (e) {\n\n                        var key = e.keyCode ? e.keyCode : e.which;\n                        var isNavigationKey = false;\n\n                        // ESC key (close)\n                        if (key === 27) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                            $scope.toggleCheckboxes(e);\n                        }\n\n\n                        // next element ( tab, down & right key )\n                        else if (key === 40 || key === 39 || ( !e.shiftKey && key == 9 )) {\n\n                            isNavigationKey = true;\n                            prevTabIndex = $scope.tabIndex;\n                            $scope.tabIndex++;\n                            if ($scope.tabIndex > formElements.length - 1) {\n                                $scope.tabIndex = 0;\n                                prevTabIndex = formElements.length - 1;\n                            }\n                            while (formElements[$scope.tabIndex].disabled === true) {\n                                $scope.tabIndex++;\n                                if ($scope.tabIndex > formElements.length - 1) {\n                                    $scope.tabIndex = 0;\n                                }\n                                if ($scope.tabIndex === prevTabIndex) {\n                                    break;\n                                }\n                            }\n                        }\n\n                        // prev element ( shift+tab, up & left key )\n                        else if (key === 38 || key === 37 || ( e.shiftKey && key == 9 )) {\n                            isNavigationKey = true;\n                            prevTabIndex = $scope.tabIndex;\n                            $scope.tabIndex--;\n                            if ($scope.tabIndex < 0) {\n                                $scope.tabIndex = formElements.length - 1;\n                                prevTabIndex = 0;\n                            }\n                            while (formElements[$scope.tabIndex].disabled === true) {\n                                $scope.tabIndex--;\n                                if ($scope.tabIndex === prevTabIndex) {\n                                    break;\n                                }\n                                if ($scope.tabIndex < 0) {\n                                    $scope.tabIndex = formElements.length - 1;\n                                }\n                            }\n                        }\n\n                        if (isNavigationKey === true) {\n\n                            e.preventDefault();\n\n                            // set focus on the checkbox\n                            formElements[$scope.tabIndex].focus();\n                            var actEl = document.activeElement;\n\n                            if (actEl.type.toUpperCase() === 'CHECKBOX') {\n                                $scope.setFocusStyle($scope.tabIndex);\n                                $scope.removeFocusStyle(prevTabIndex);\n                            }\n                            else {\n                                $scope.removeFocusStyle(prevTabIndex);\n                                $scope.removeFocusStyle(helperItemsLength);\n                                $scope.removeFocusStyle(formElements.length - 1);\n                            }\n                        }\n\n                        isNavigationKey = false;\n                    }\n\n                    // set (add) CSS style on selected row\n                    $scope.setFocusStyle = function (tabIndex) {\n                        angular.element(formElements[tabIndex]).parent().parent().parent().addClass('multiSelectFocus');\n                    }\n\n                    // remove CSS style on selected row\n                    $scope.removeFocusStyle = function (tabIndex) {\n                        angular.element(formElements[tabIndex]).parent().parent().parent().removeClass('multiSelectFocus');\n                    }\n\n                    /*********************\n                     *********************\n                     *\n                     * 1) Initializations\n                     *\n                     *********************\n                     *********************/\n\n                        // attrs to $scope - attrs-$scope - attrs - $scope\n                        // Copy some properties that will be used on the template. They need to be in the $scope.\n                    $scope.groupProperty = attrs.groupProperty;\n                    $scope.tickProperty = attrs.tickProperty;\n                    $scope.directiveId = attrs.directiveId;\n\n                    // Unfortunately I need to add these grouping properties into the input model\n                    var tempStr = genRandomString(5);\n                    $scope.indexProperty = 'idx_' + tempStr;\n                    $scope.spacingProperty = 'spc_' + tempStr;\n\n                    // set orientation css\n                    if (typeof attrs.orientation !== 'undefined') {\n\n                        if (attrs.orientation.toUpperCase() === 'HORIZONTAL') {\n                            $scope.orientationH = true;\n                            $scope.orientationV = false;\n                        }\n                        else {\n                            $scope.orientationH = false;\n                            $scope.orientationV = true;\n                        }\n                    }\n\n                    // get elements required for DOM operation\n                    checkBoxLayer = element.children().children().next()[0];\n\n                    // set max-height property if provided\n                    if (typeof attrs.maxHeight !== 'undefined') {\n                        var layer = element.children().children().children()[0];\n                        angular.element(layer).attr(\"style\", \"height:\" + attrs.maxHeight + \"; overflow-y:scroll;\");\n                    }\n\n                    // some flags for easier checking\n                    for (var property in $scope.helperStatus) {\n                        if ($scope.helperStatus.hasOwnProperty(property)) {\n                            if (\n                                typeof attrs.helperElements !== 'undefined'\n                                && attrs.helperElements.toUpperCase().indexOf(property.toUpperCase()) === -1\n                            ) {\n                                $scope.helperStatus[property] = false;\n                            }\n                        }\n                    }\n                    if (typeof attrs.selectionMode !== 'undefined' && attrs.selectionMode.toUpperCase() === 'SINGLE') {\n                        $scope.helperStatus['all'] = false;\n                        $scope.helperStatus['none'] = false;\n                    }\n\n                    // helper button icons.. I guess you can use html tag here if you want to.\n                    $scope.icon = {};\n                    $scope.icon.selectAll = '&#10003;';    // a tick icon\n                    $scope.icon.selectNone = '&times;';     // x icon\n                    $scope.icon.reset = '&#8630;';     // undo icon\n                    // this one is for the selected items\n                    $scope.icon.tickMark = '<i class=\"md md-done\"></i>';    // a tick icon\n\n                    // configurable button labels\n                    if (typeof attrs.translation !== 'undefined') {\n                        $scope.lang.selectAll = $sce.trustAsHtml($scope.icon.selectAll + '&nbsp;&nbsp;' + $scope.translation.selectAll);\n                        $scope.lang.selectNone = $sce.trustAsHtml($scope.icon.selectNone + '&nbsp;&nbsp;' + $scope.translation.selectNone);\n                        $scope.lang.reset = $sce.trustAsHtml($scope.icon.reset + '&nbsp;&nbsp;' + $scope.translation.reset);\n                        $scope.lang.search = $scope.translation.search;\n                        $scope.lang.nothingSelected = $sce.trustAsHtml($scope.translation.nothingSelected);\n                    }\n                    else {\n                        $scope.lang.selectAll = $sce.trustAsHtml($scope.icon.selectAll + '&nbsp;&nbsp;Select All');\n                        $scope.lang.selectNone = $sce.trustAsHtml($scope.icon.selectNone + '&nbsp;&nbsp;Select None');\n                        $scope.lang.reset = $sce.trustAsHtml($scope.icon.reset + '&nbsp;&nbsp;Reset');\n                        $scope.lang.search = 'Search...';\n                        $scope.lang.nothingSelected = 'None Selected';\n                    }\n                    $scope.icon.tickMark = $sce.trustAsHtml($scope.icon.tickMark);\n\n                    // min length of keyword to trigger the filter function\n                    if (typeof attrs.MinSearchLength !== 'undefined' && parseInt(attrs.MinSearchLength) > 0) {\n                        vMinSearchLength = Math.floor(parseInt(attrs.MinSearchLength));\n                    }\n\n                    /*******************************************************\n                     *******************************************************\n                     *\n                     * 2) Logic starts here, initiated by watch 1 & watch 2\n                     *\n                     *******************************************************\n                     *******************************************************/\n\n                        // watch1, for changes in input model property\n                        // updates multi-select when user select/deselect a single checkbox programatically\n                        // https://github.com/isteven/angular-multi-select/issues/8\n                    $scope.$watch('inputModel', function (newVal) {\n                        if (newVal) {\n                            $scope.refreshOutputModel();\n                            $scope.refreshButton();\n                        }\n                    }, true);\n\n                    // watch2 for changes in input model as a whole\n                    // this on updates the multi-select when a user load a whole new input-model. We also update the $scope.backUp variable\n                    $scope.$watch('inputModel', function (newVal) {\n                        if (newVal) {\n                            $scope.backUp = angular.copy($scope.inputModel);\n                            $scope.updateFilter();\n                            $scope.prepareGrouping();\n                            $scope.prepareIndex();\n                            $scope.refreshOutputModel();\n                            $scope.refreshButton();\n                        }\n                    });\n\n                    // watch for changes in directive state (disabled or enabled)\n                    $scope.$watch('isDisabled', function (newVal) {\n                        $scope.isDisabled = newVal;\n                    });\n\n                    // this is for touch enabled devices. We don't want to hide checkboxes on scroll.\n                    var onTouchStart = function (e) {\n                        $scope.$apply(function () {\n                            $scope.scrolled = false;\n                        });\n                    };\n                    angular.element(document).bind('touchstart', onTouchStart);\n                    var onTouchMove = function (e) {\n                        $scope.$apply(function () {\n                            $scope.scrolled = true;\n                        });\n                    };\n                    angular.element(document).bind('touchmove', onTouchMove);\n\n                    // unbind document events to prevent memory leaks\n                    $scope.$on('$destroy', function () {\n                        angular.element(document).unbind('touchstart', onTouchStart);\n                        angular.element(document).unbind('touchmove', onTouchMove);\n                    });\n                }\n            }\n        }])\n        .run(['$templateCache', function ($templateCache) {\n            var template =\n                '<span class=\"multiSelect inlineBlock\">' +\n                    // main button\n                '<button id=\"{{directiveId}}\" type=\"button\"' +\n                'ng-click=\"toggleCheckboxes( $event ); refreshSelectedItems(); refreshButton(); prepareGrouping; prepareIndex();\"' +\n                'ng-bind-html=\"varButtonLabel\"' +\n                'ng-disabled=\"disable-button\"' +\n                '>' +\n                '</button>' +\n                    // overlay layer\n                '<div class=\"checkboxLayer\">' +\n                    // container of the helper elements\n                '<div class=\"helperContainer\" ng-if=\"helperStatus.filter || helperStatus.all || helperStatus.none || helperStatus.reset \">' +\n                    // container of the first 3 buttons, select all, none and reset\n                '<div class=\"line\" ng-if=\"helperStatus.all || helperStatus.none || helperStatus.reset \">' +\n                    // select all\n                '<button type=\"button\" class=\"helperButton\"' +\n                'ng-disabled=\"isDisabled\"' +\n                'ng-if=\"helperStatus.all\"' +\n                'ng-click=\"select( \\'all\\', $event );\"' +\n                'ng-bind-html=\"lang.selectAll\">' +\n                '</button>' +\n                    // select none\n                '<button type=\"button\" class=\"helperButton\"' +\n                'ng-disabled=\"isDisabled\"' +\n                'ng-if=\"helperStatus.none\"' +\n                'ng-click=\"select( \\'none\\', $event );\"' +\n                'ng-bind-html=\"lang.selectNone\">' +\n                '</button>' +\n                    // reset\n                '<button type=\"button\" class=\"helperButton reset\"' +\n                'ng-disabled=\"isDisabled\"' +\n                'ng-if=\"helperStatus.reset\"' +\n                'ng-click=\"select( \\'reset\\', $event );\"' +\n                'ng-bind-html=\"lang.reset\">' +\n                '</button>' +\n                '</div>' +\n                    // the search box\n                '<div class=\"line\" style=\"position:relative\" ng-if=\"helperStatus.filter\">' +\n                    // textfield\n                '<input placeholder=\"{{lang.search}}\" type=\"text\"' +\n                'ng-click=\"select( \\'filter\\', $event )\" ' +\n                'ng-model=\"inputLabel.labelFilter\" ' +\n                'ng-change=\"searchChanged()\" class=\"inputFilter\"' +\n                '/>' +\n                    // clear button\n                '<button type=\"button\" class=\"clearButton\" ng-click=\"clearClicked( $event )\" ></button> ' +\n                '</div> ' +\n                '</div> ' +\n                    // selection items\n                '<div class=\"checkBoxContainer\">' +\n                '<div ' +\n                'ng-repeat=\"item in filteredModel | filter:removeGroupEndMarker\" class=\"multiSelectItem\"' +\n                'ng-class=\"{selected: item[ tickProperty ], horizontal: orientationH, vertical: orientationV, multiSelectGroup:item[ groupProperty ], disabled:itemIsDisabled( item )}\"' +\n                'ng-click=\"syncItems( item, $event, $index );\" ' +\n                'ng-mouseleave=\"removeFocusStyle( tabIndex );\"> ' +\n                    // this is the spacing for grouped items\n                '<div class=\"acol\" ng-if=\"item[ spacingProperty ] > 0\" ng-repeat=\"i in numberToArray( item[ spacingProperty ] ) track by $index\">' +\n                '</div>  ' +\n                '<div class=\"acol\">' +\n                '<label>' +\n                    // input, so that it can accept focus on keyboard click\n                '<input class=\"checkbox focusable\" type=\"checkbox\" ' +\n                'ng-disabled=\"itemIsDisabled( item )\" ' +\n                'ng-checked=\"item[ tickProperty ]\" ' +\n                'ng-click=\"syncItems( item, $event, $index )\" />' +\n                    // item label using ng-bind-hteml\n                '<span ' +\n                'ng-class=\"{disabled:itemIsDisabled( item )}\" ' +\n                'ng-bind-html=\"writeLabel( item, \\'itemLabel\\' )\">' +\n                '</span>' +\n                '</label>' +\n                '</div>' +\n                    // the tick/check mark\n                '<span class=\"tickMark\" ng-if=\"item[ groupProperty ] !== true && item[ tickProperty ] === true\" ng-bind-html=\"icon.tickMark\"></span>' +\n                '</div>' +\n                '</div>' +\n                '</div>' +\n                '</span>';\n            $templateCache.put('isteven-multi-select.htm', template);\n        }]);\n\n}());\n\n",
    "(function (angular, factory) {\n    'use strict';\n\n    if (typeof define === 'function' && define.amd) {\n        define(['angular'], function (angular) {\n            return factory(angular);\n        });\n    } else {\n        return factory(angular);\n    }\n}(angular || null, function (angular) {\n    'use strict';\n    /**\n     * ngTable: Table + Angular JS\n     *\n     * @author Vitalii Savchuk <esvit666@gmail.com>\n     * @url https://github.com/esvit/ng-table/\n     * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n     */\n\n    /**\n     * @ngdoc module\n     * @name ngTable\n     * @description ngTable: Table + Angular JS\n     * @example\n     <doc:example>\n     <doc:source>\n     <script>\n     var app = angular.module('myApp', ['ngTable']);\n     app.controller('MyCtrl', function($scope) {\n                    $scope.users = [\n                        {name: \"Moroni\", age: 50},\n                        {name: \"Tiancum\", age: 43},\n                        {name: \"Jacob\", age: 27},\n                        {name: \"Nephi\", age: 29},\n                        {name: \"Enos\", age: 34}\n                    ];\n                });\n     </script>\n     <table ng-table class=\"table\">\n     <tr ng-repeat=\"user in users\">\n     <td data-title=\"'Name'\">{{user.name}}</td>\n     <td data-title=\"'Age'\">{{user.age}}</td>\n     </tr>\n     </table>\n     </doc:source>\n     </doc:example>\n     */\n    var app = angular.module('ngTable', []);\n    /**\n     * ngTable: Table + Angular JS\n     *\n     * @author Vitalii Savchuk <esvit666@gmail.com>\n     * @url https://github.com/esvit/ng-table/\n     * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n     */\n\n    /**\n     * @ngdoc value\n     * @name ngTable.value:ngTableDefaultParams\n     * @description Default Parameters for ngTable\n     */\n    app.value('ngTableDefaults', {\n        params: {},\n        settings: {}\n    });\n\n    /**\n     * @ngdoc service\n     * @name ngTable.factory:NgTableParams\n     * @description Parameters manager for ngTable\n     */\n\n    app.factory('NgTableParams', ['$q', '$log', 'ngTableDefaults', function ($q, $log, ngTableDefaults) {\n        var isNumber = function (n) {\n            return !isNaN(parseFloat(n)) && isFinite(n);\n        };\n        var NgTableParams = function (baseParameters, baseSettings) {\n            var self = this,\n                log = function () {\n                    if (settings.debugMode && $log.debug) {\n                        $log.debug.apply(this, arguments);\n                    }\n                };\n\n            this.data = [];\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#parameters\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Set new parameters or get current parameters\n             *\n             * @param {string} newParameters      New parameters\n             * @param {string} parseParamsFromUrl Flag if parse parameters like in url\n             * @returns {Object} Current parameters or `this`\n             */\n            this.parameters = function (newParameters, parseParamsFromUrl) {\n                parseParamsFromUrl = parseParamsFromUrl || false;\n                if (angular.isDefined(newParameters)) {\n                    for (var key in newParameters) {\n                        var value = newParameters[key];\n                        if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n                            var keys = key.split(/\\[(.*)\\]/).reverse()\n                            var lastKey = '';\n                            for (var i = 0, len = keys.length; i < len; i++) {\n                                var name = keys[i];\n                                if (name !== '') {\n                                    var v = value;\n                                    value = {};\n                                    value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);\n                                }\n                            }\n                            if (lastKey === 'sorting') {\n                                params[lastKey] = {};\n                            }\n                            params[lastKey] = angular.extend(params[lastKey] || {}, value[lastKey]);\n                        } else {\n                            params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);\n                        }\n                    }\n                    log('ngTable: set parameters', params);\n                    return this;\n                }\n                return params;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#settings\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Set new settings for table\n             *\n             * @param {string} newSettings New settings or undefined\n             * @returns {Object} Current settings or `this`\n             */\n            this.settings = function (newSettings) {\n                if (angular.isDefined(newSettings)) {\n                    if (angular.isArray(newSettings.data)) {\n                        //auto-set the total from passed in data\n                        newSettings.total = newSettings.data.length;\n                    }\n                    settings = angular.extend(settings, newSettings);\n                    log('ngTable: set settings', settings);\n                    return this;\n                }\n                return settings;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#page\n             * @methodOf ngTable.factory:NgTableParams\n             * @description If parameter page not set return current page else set current page\n             *\n             * @param {string} page Page number\n             * @returns {Object|Number} Current page or `this`\n             */\n            this.page = function (page) {\n                return angular.isDefined(page) ? this.parameters({\n                    'page': page\n                }) : params.page;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#total\n             * @methodOf ngTable.factory:NgTableParams\n             * @description If parameter total not set return current quantity else set quantity\n             *\n             * @param {string} total Total quantity of items\n             * @returns {Object|Number} Current page or `this`\n             */\n            this.total = function (total) {\n                return angular.isDefined(total) ? this.settings({\n                    'total': total\n                }) : settings.total;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#count\n             * @methodOf ngTable.factory:NgTableParams\n             * @description If parameter count not set return current count per page else set count per page\n             *\n             * @param {string} count Count per number\n             * @returns {Object|Number} Count per page or `this`\n             */\n            this.count = function (count) {\n                // reset to first page because can be blank page\n                return angular.isDefined(count) ? this.parameters({\n                    'count': count,\n                    'page': 1\n                }) : params.count;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#filter\n             * @methodOf ngTable.factory:NgTableParams\n             * @description If parameter page not set return current filter else set current filter\n             *\n             * @param {string} filter New filter\n             * @returns {Object} Current filter or `this`\n             */\n            this.filter = function (filter) {\n                return angular.isDefined(filter) ? this.parameters({\n                    'filter': filter,\n                    'page': 1\n                }) : params.filter;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#sorting\n             * @methodOf ngTable.factory:NgTableParams\n             * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.\n             *\n             * @param {string} sorting New sorting\n             * @returns {Object} Current sorting or `this`\n             */\n            this.sorting = function (sorting) {\n                if (arguments.length == 2) {\n                    var sortArray = {};\n                    sortArray[sorting] = arguments[1];\n                    this.parameters({\n                        'sorting': sortArray\n                    });\n                    return this;\n                }\n                return angular.isDefined(sorting) ? this.parameters({\n                    'sorting': sorting\n                }) : params.sorting;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#isSortBy\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Checks sort field\n             *\n             * @param {string} field     Field name\n             * @param {string} direction Direction of sorting 'asc' or 'desc'\n             * @returns {Array} Return true if field sorted by direction\n             */\n            this.isSortBy = function (field, direction) {\n                return angular.isDefined(params.sorting[field]) && angular.equals(params.sorting[field], direction);\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#orderBy\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Return object of sorting parameters for angular filter\n             *\n             * @returns {Array} Array like: [ '-name', '+age' ]\n             */\n            this.orderBy = function () {\n                var sorting = [];\n                for (var column in params.sorting) {\n                    sorting.push((params.sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n                }\n                return sorting;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#getData\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Called when updated some of parameters for get new data\n             *\n             * @param {Object} $defer promise object\n             * @param {Object} params New parameters\n             */\n            this.getData = function ($defer, params) {\n                if (angular.isArray(this.data) && angular.isObject(params)) {\n                    $defer.resolve(this.data.slice((params.page() - 1) * params.count(), params.page() * params.count()));\n                } else {\n                    $defer.resolve([]);\n                }\n                return $defer.promise;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#getGroups\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Return groups for table grouping\n             */\n            this.getGroups = function ($defer, column) {\n                var defer = $q.defer();\n\n                defer.promise.then(function (data) {\n                    var groups = {};\n                    angular.forEach(data, function (item) {\n                        var groupName = angular.isFunction(column) ? column(item) : item[column];\n\n                        groups[groupName] = groups[groupName] || {\n                            data: []\n                        };\n                        groups[groupName]['value'] = groupName;\n                        groups[groupName].data.push(item);\n                    });\n                    var result = [];\n                    for (var i in groups) {\n                        result.push(groups[i]);\n                    }\n                    log('ngTable: refresh groups', result);\n                    $defer.resolve(result);\n                });\n                return this.getData(defer, self);\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#generatePagesArray\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Generate array of pages\n             *\n             * @param {boolean} currentPage which page must be active\n             * @param {boolean} totalItems  Total quantity of items\n             * @param {boolean} pageSize    Quantity of items on page\n             * @returns {Array} Array of pages\n             */\n            this.generatePagesArray = function (currentPage, totalItems, pageSize) {\n                var maxBlocks, maxPage, maxPivotPages, minPage, numPages, pages;\n                maxBlocks = 6;\n                pages = [];\n                numPages = Math.ceil(totalItems / pageSize);\n                if (numPages > 1) {\n                    pages.push({\n                        type: 'prev',\n                        number: Math.max(1, currentPage - 1),\n                        active: currentPage > 1\n                    });\n                    pages.push({\n                        type: 'first',\n                        number: 1,\n                        active: currentPage > 1,\n                        current: currentPage === 1\n                    });\n                    maxPivotPages = Math.round((maxBlocks - 5) / 2);\n                    minPage = Math.max(2, currentPage - maxPivotPages);\n                    maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n                    minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n                    var i = minPage;\n                    while (i <= maxPage) {\n                        if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {\n                            pages.push({\n                                type: 'more',\n                                active: false\n                            });\n                        } else {\n                            pages.push({\n                                type: 'page',\n                                number: i,\n                                active: currentPage !== i,\n                                current: currentPage === i\n                            });\n                        }\n                        i++;\n                    }\n                    pages.push({\n                        type: 'last',\n                        number: numPages,\n                        active: currentPage !== numPages,\n                        current: currentPage === numPages\n                    });\n                    pages.push({\n                        type: 'next',\n                        number: Math.min(numPages, currentPage + 1),\n                        active: currentPage < numPages\n                    });\n                }\n                return pages;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#url\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Return groups for table grouping\n             *\n             * @param {boolean} asString flag indicates return array of string or object\n             * @returns {Array} If asString = true will be return array of url string parameters else key-value object\n             */\n            this.url = function (asString) {\n                asString = asString || false;\n                var pairs = (asString ? [] : {});\n                for (var key in params) {\n                    if (params.hasOwnProperty(key)) {\n                        var item = params[key],\n                            name = encodeURIComponent(key);\n                        if (typeof item === \"object\") {\n                            for (var subkey in item) {\n                                if (!angular.isUndefined(item[subkey]) && item[subkey] !== \"\") {\n                                    var pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n                                    if (asString) {\n                                        pairs.push(pname + \"=\" + item[subkey]);\n                                    } else {\n                                        pairs[pname] = item[subkey];\n                                    }\n                                }\n                            }\n                        } else if (!angular.isFunction(item) && !angular.isUndefined(item) && item !== \"\") {\n                            if (asString) {\n                                pairs.push(name + \"=\" + encodeURIComponent(item));\n                            } else {\n                                pairs[name] = encodeURIComponent(item);\n                            }\n                        }\n                    }\n                }\n                return pairs;\n            };\n\n            /**\n             * @ngdoc method\n             * @name ngTable.factory:NgTableParams#reload\n             * @methodOf ngTable.factory:NgTableParams\n             * @description Reload table data\n             */\n            this.reload = function () {\n                var $defer = $q.defer(),\n                    self = this,\n                    pData = null;\n\n                if (!settings.$scope) {\n                    return;\n                }\n\n                settings.$loading = true;\n                if (settings.groupBy) {\n                    pData = settings.getGroups($defer, settings.groupBy, this);\n                } else {\n                    pData = settings.getData($defer, this);\n                }\n                log('ngTable: reload data');\n\n                if (!pData) {\n                    // If getData resolved the $defer, and didn't promise us data,\n                    //   create a promise from the $defer. We need to return a promise.\n                    pData = $defer.promise;\n                }\n                return pData.then(function (data) {\n                    settings.$loading = false;\n                    log('ngTable: current scope', settings.$scope);\n                    if (settings.groupBy) {\n                        self.data = data;\n                        if (settings.$scope) settings.$scope.$groups = data;\n                    } else {\n                        self.data = data;\n                        if (settings.$scope) settings.$scope.$data = data;\n                    }\n                    if (settings.$scope) settings.$scope.pages = self.generatePagesArray(self.page(), self.total(), self.count());\n                    settings.$scope.$emit('ngTableAfterReloadData');\n                    return data;\n                });\n            };\n\n            this.reloadPages = function () {\n                var self = this;\n                settings.$scope.pages = self.generatePagesArray(self.page(), self.total(), self.count());\n            };\n\n            var params = this.$params = {\n                page: 1,\n                count: 1,\n                filter: {},\n                sorting: {},\n                group: {},\n                groupBy: null\n            };\n            angular.extend(params, ngTableDefaults.params);\n\n            var settings = {\n                $scope: null, // set by ngTable controller\n                $loading: false,\n                data: null, //allows data to be set when table is initialized\n                total: 0,\n                defaultSort: 'desc',\n                filterDelay: 750,\n                counts: [10, 25, 50, 100],\n                sortingIndicator: 'span',\n                getGroups: this.getGroups,\n                getData: this.getData\n            };\n            angular.extend(settings, ngTableDefaults.settings);\n\n            this.settings(baseSettings);\n            this.parameters(baseParameters, true);\n            return this;\n        };\n        return NgTableParams;\n    }]);\n\n    /**\n     * @ngdoc service\n     * @name ngTable.factory:ngTableParams\n     * @description Backwards compatible shim for lowercase 'n' in NgTableParams\n     */\n    app.factory('ngTableParams', ['NgTableParams', function (NgTableParams) {\n        return NgTableParams;\n    }]);\n\n    /**\n     * ngTable: Table + Angular JS\n     *\n     * @author Vitalii Savchuk <esvit666@gmail.com>\n     * @url https://github.com/esvit/ng-table/\n     * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n     */\n\n    /**\n     * @ngdoc object\n     * @name ngTable.directive:ngTable.ngTableController\n     *\n     * @description\n     * Each {@link ngTable.directive:ngTable ngTable} directive creates an instance of `ngTableController`\n     */\n    app.controller('ngTableController', ['$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element',\n        'ngTableColumn',\n        function ($scope, NgTableParams, $timeout, $parse, $compile, $attrs, $element, ngTableColumn) {\n            var isFirstTimeLoad = true;\n            $scope.$filterRow = {};\n            $scope.$loading = false;\n\n            // until such times as the directive uses an isolated scope, we need to ensure that the check for\n            // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n            // field on a $scope higher up in the prototype chain\n            if (!$scope.hasOwnProperty(\"params\")) {\n                $scope.params = new NgTableParams();\n                $scope.params.isNullInstance = true;\n            }\n            $scope.params.settings().$scope = $scope;\n\n            var delayFilter = (function () {\n                var timer = 0;\n                return function (callback, ms) {\n                    $timeout.cancel(timer);\n                    timer = $timeout(callback, ms);\n                };\n            })();\n\n            function resetPage() {\n                $scope.params.$params.page = 1;\n            }\n\n            $scope.$watch('params.$params', function (newParams, oldParams) {\n\n                if (newParams === oldParams) {\n                    return;\n                }\n\n                $scope.params.settings().$scope = $scope;\n\n                if (!angular.equals(newParams.filter, oldParams.filter)) {\n                    var maybeResetPage = isFirstTimeLoad ? angular.noop : resetPage;\n                    delayFilter(function () {\n                        maybeResetPage();\n                        $scope.params.reload();\n                    }, $scope.params.settings().filterDelay);\n                } else {\n                    $scope.params.reload();\n                }\n\n                if (!$scope.params.isNullInstance) {\n                    isFirstTimeLoad = false;\n                }\n\n            }, true);\n\n            this.getParams = function () {\n                return $scope.params;\n            };\n\n            this.compileDirectiveTemplates = function () {\n                if (!$element.hasClass('ng-table')) {\n                    $scope.templates = {\n                        header: ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html'),\n                        pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')\n                    };\n                    $element.addClass('ng-table');\n                    var headerTemplate = null;\n                    if ($element.find('> thead').length === 0) {\n                        headerTemplate = angular.element(document.createElement('thead')).attr('ng-include', 'templates.header');\n                        $element.prepend(headerTemplate);\n                    }\n                    var paginationTemplate = angular.element(document.createElement('div')).attr({\n                        'ng-table-pagination': 'params',\n                        'template-url': 'templates.pagination'\n                    });\n                    $element.after(paginationTemplate);\n                    if (headerTemplate) {\n                        $compile(headerTemplate)($scope);\n                    }\n                    $compile(paginationTemplate)($scope);\n                }\n            };\n\n            this.loadFilterData = function ($columns) {\n                angular.forEach($columns, function ($column) {\n                    var def;\n                    def = $column.filterData($scope, {\n                        $column: $column\n                    });\n                    if (!def) {\n                        delete $column.filterData;\n                        return;\n                    }\n\n                    // if we're working with a deferred object, let's wait for the promise\n                    if ((angular.isObject(def) && angular.isObject(def.promise))) {\n                        delete $column.filterData;\n                        return def.promise.then(function (data) {\n                            // our deferred can eventually return arrays, functions and objects\n                            if (!angular.isArray(data) && !angular.isFunction(data) && !angular.isObject(data)) {\n                                // if none of the above was found - we just want an empty array\n                                data = [];\n                            } else if (angular.isArray(data)) {\n                                data.unshift({\n                                    title: '-',\n                                    id: ''\n                                });\n                            }\n                            $column.data = data;\n                        });\n                    }\n                    // otherwise, we just return what the user gave us. It could be a function, array, object, whatever\n                    else {\n                        return $column.data = def;\n                    }\n                });\n            };\n\n            this.buildColumns = function (columns) {\n                return columns.map(function (col) {\n                    return ngTableColumn.buildColumn(col, $scope)\n                })\n            };\n\n            this.setupBindingsToInternalScope = function (tableParamsExpr) {\n\n                // note: this we're setting up watches to simulate angular's isolated scope bindings\n\n                // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n                // $watch for value equivalence. This is because ngTableParams references the current page of data as\n                // a field and it's important not to watch this\n                var tableParamsGetter = $parse(tableParamsExpr);\n                $scope.$watch(tableParamsGetter, (function (params) {\n                    if (angular.isUndefined(params)) {\n                        return;\n                    }\n                    $scope.paramsModel = tableParamsGetter;\n                    $scope.params = params;\n                }), false);\n\n                if ($attrs.showFilter) {\n                    $scope.$parent.$watch($attrs.showFilter, function (value) {\n                        $scope.show_filter = value;\n                    });\n                }\n                if ($attrs.disableFilter) {\n                    $scope.$parent.$watch($attrs.disableFilter, function (value) {\n                        $scope.$filterRow.disabled = value;\n                    });\n                }\n            };\n\n            $scope.sortBy = function ($column, event) {\n                var parsedSortable = $column.sortable && $column.sortable();\n                if (!parsedSortable) {\n                    return;\n                }\n                var defaultSort = $scope.params.settings().defaultSort;\n                var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');\n                var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && ($scope.params.sorting()[parsedSortable] === defaultSort);\n                var sortingParams = (event.ctrlKey || event.metaKey) ? $scope.params.sorting() : {};\n                sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);\n                $scope.params.parameters({\n                    sorting: sortingParams\n                });\n            };\n        }]);\n\n\n    /**\n     * @ngdoc service\n     * @name ngTable.factory:ngTableColumn\n     *\n     * @description\n     * Service to construct a $column definition used by {@link ngTable.directive:ngTable ngTable} directive\n     */\n    app.factory('ngTableColumn', [function () {\n\n        var defaults = {\n            'class': function () {\n                return '';\n            },\n            filter: function () {\n                return false;\n            },\n            filterData: angular.noop,\n            headerTemplateURL: function () {\n                return false;\n            },\n            headerTitle: function () {\n                return ' ';\n            },\n            sortable: function () {\n                return false;\n            },\n            show: function () {\n                return true;\n            },\n            title: function () {\n                return ' ';\n            },\n            titleAlt: function () {\n                return '';\n            }\n        };\n\n        /**\n         * @ngdoc method\n         * @name ngTable.factory:ngTableColumn#buildColumn\n         * @methodOf ngTable.factory:ngTableColumn\n         * @description Creates a $column for use within a header template\n         *\n         * @param {Object} column an existing $column or simple column data object\n         * @param {Scope} defaultScope the $scope to supply to the $column getter methods when not supplied by caller\n         * @returns {Object} a $column object\n         */\n        function buildColumn(column, defaultScope) {\n            // note: we're not modifying the original column object. This helps to avoid unintended side affects\n            var extendedCol = Object.create(column);\n            for (var prop in defaults) {\n                if (extendedCol[prop] === undefined) {\n                    extendedCol[prop] = defaults[prop];\n                }\n                if (!angular.isFunction(extendedCol[prop])) {\n                    // wrap raw field values with \"getter\" functions\n                    // - this is to ensure consistency with how ngTable.compile builds columns\n                    // - note that the original column object is being \"proxied\"; this is important\n                    //   as it ensure that any changes to the original object will be returned by the \"getter\"\n                    (function (prop1) {\n                        extendedCol[prop1] = function () {\n                            return column[prop1];\n                        };\n                    })(prop);\n                }\n                (function (prop1) {\n                    // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n                    var getterFn = extendedCol[prop1];\n                    extendedCol[prop1] = function () {\n                        if (arguments.length === 0) {\n                            return getterFn.call(column, defaultScope);\n                        } else {\n                            return getterFn.apply(column, arguments);\n                        }\n                    };\n                })(prop);\n            }\n            return extendedCol;\n        }\n\n        return {\n            buildColumn: buildColumn\n        };\n    }]);\n\n    /**\n     * ngTable: Table + Angular JS\n     *\n     * @author Vitalii Savchuk <esvit666@gmail.com>\n     * @url https://github.com/esvit/ng-table/\n     * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n     */\n\n    /**\n     * @ngdoc directive\n     * @name ngTable.directive:ngTable\n     * @restrict A\n     *\n     * @description\n     * Directive that instantiates {@link ngTable.directive:ngTable.ngTableController ngTableController}.\n     */\n    app.directive('ngTable', ['$q', '$parse',\n        function ($q, $parse) {\n            'use strict';\n\n            return {\n                restrict: 'A',\n                priority: 1001,\n                scope: true,\n                controller: 'ngTableController',\n                compile: function (element) {\n                    var columns = [],\n                        i = 0,\n                        row = null;\n\n                    // IE 8 fix :not(.ng-table-group) selector\n                    angular.forEach(angular.element(element.find('tr')), function (tr) {\n                        tr = angular.element(tr);\n                        if (!tr.hasClass('ng-table-group') && !row) {\n                            row = tr;\n                        }\n                    });\n                    if (!row) {\n                        return;\n                    }\n                    angular.forEach(row.find('td'), function (item) {\n                        var el = angular.element(item);\n                        if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n                            return;\n                        }\n\n                        var getAttrValue = function (attr) {\n                            return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                        };\n\n                        var parsedAttribute = function (attr) {\n                            var expr = getAttrValue(attr);\n                            if (!expr) {\n                                return undefined;\n                            }\n                            return function (scope, locals) {\n                                return $parse(expr)(scope, angular.extend(locals || {}, {\n                                    $columns: columns\n                                }));\n                            };\n                        };\n\n                        var titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n                        if (titleExpr) {\n                            el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n                        }\n                        // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n                        // a corresponding \"safe\" default\n                        columns.push({\n                            id: i++,\n                            title: parsedAttribute('title'),\n                            titleAlt: parsedAttribute('title-alt'),\n                            headerTitle: parsedAttribute('header-title'),\n                            sortable: parsedAttribute('sortable'),\n                            'class': parsedAttribute('header-class'),\n                            filter: parsedAttribute('filter'),\n                            headerTemplateURL: parsedAttribute('header'),\n                            filterData: parsedAttribute('filter-data'),\n                            show: (el.attr(\"ng-show\") ? function (scope) {\n                                return $parse(el.attr(\"ng-show\"))(scope);\n                            } : undefined)\n                        });\n                    });\n                    return function (scope, element, attrs, controller) {\n                        scope.$columns = columns = controller.buildColumns(columns);\n\n                        controller.setupBindingsToInternalScope(attrs.ngTable);\n                        controller.loadFilterData(columns);\n                        controller.compileDirectiveTemplates();\n                    };\n                }\n            }\n        }\n    ]);\n\n    app.directive('ngTableSortHeader', function () {\n        return {\n            scope: {\n                ngTableSortHeader: '@'\n            },\n            restrict: 'AE',\n            require: '^ngTable',\n            transclude: true,\n            replace: true,\n\n            link: function (scope, element, attrs, ngTable) {\n                var tableParams = ngTable.getParams();\n\n                scope.$watch(function () {\n                    return ngTable.getParams();\n                }, function (params) {\n                    tableParams = params;\n                });\n\n                scope.isSortBy = function (order) {\n                    return tableParams.isSortBy(scope.ngTableSortHeader, order);\n                };\n\n                scope.sorting = function () {\n                    var sort = {};\n\n                    sort[scope.ngTableSortHeader] = scope.isSortBy('asc') ? 'desc' : 'asc';\n\n                    tableParams.sorting(sort);\n                };\n\n            },\n            template: '<th class=\"sortable\"\\n    ng-class=\"{\\'sort-asc\\': isSortBy(\\'asc\\'), \\'sort-desc\\': isSortBy(\\'desc\\')}\"\\n    ng-click=\"sorting()\">\\n    <div class=\"sort-indicator\" ng-transclude>\\n        \\n    </div>\\n</th>'\n        };\n    });\n\n    /**\n     * @ngdoc directive\n     * @name ngTable.directive:ngTableDynamic\n     * @restrict A\n     *\n     * @description\n     * A dynamic version of the {@link ngTable.directive:ngTable ngTable} directive that accepts a dynamic list of columns\n     * definitions to render\n     */\n    app.directive('ngTableDynamic', ['$parse', function ($parse) {\n\n        function parseDirectiveExpression(attr) {\n            if (!attr || attr.indexOf(\" with \") > -1) {\n                var parts = attr.split(/\\s+with\\s+/);\n                return {\n                    tableParams: parts[0],\n                    columns: parts[1]\n                };\n            } else {\n                throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n            }\n        }\n\n        return {\n            restrict: 'A',\n            priority: 1001,\n            scope: true,\n            controller: 'ngTableController',\n            compile: function (tElement) {\n                var row;\n\n                // IE 8 fix :not(.ng-table-group) selector\n                angular.forEach(angular.element(tElement.find('tr')), function (tr) {\n                    tr = angular.element(tr);\n                    if (!tr.hasClass('ng-table-group') && !row) {\n                        row = tr;\n                    }\n                });\n                if (!row) {\n                    return;\n                }\n\n                angular.forEach(row.find('td'), function (item) {\n                    var el = angular.element(item);\n                    var getAttrValue = function (attr) {\n                        return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                    };\n\n                    // this used in responsive table\n                    var titleExpr = getAttrValue('title');\n                    if (!titleExpr) {\n                        el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n                    }\n                    var showExpr = el.attr('ng-show');\n                    if (!showExpr) {\n                        el.attr('ng-show', '$columns[$index].show(this)');\n                    }\n                });\n\n                return function (scope, element, attrs, controller) {\n                    var expr = parseDirectiveExpression(attrs.ngTableDynamic);\n                    var columns = $parse(expr.columns)(scope) || [];\n                    scope.$columns = controller.buildColumns(columns);\n\n                    controller.setupBindingsToInternalScope(expr.tableParams);\n                    controller.loadFilterData(scope.$columns);\n                    controller.compileDirectiveTemplates();\n                };\n            }\n        };\n    }]);\n\n    /**\n     * ngTable: Table + Angular JS\n     *\n     * @author Vitalii Savchuk <esvit666@gmail.com>\n     * @url https://github.com/esvit/ng-table/\n     * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n     */\n\n    /**\n     * @ngdoc directive\n     * @name ngTable.directive:ngTablePagination\n     * @restrict A\n     */\n    app.directive('ngTablePagination', ['$compile',\n        function ($compile) {\n            'use strict';\n\n            return {\n                restrict: 'A',\n                scope: {\n                    'params': '=ngTablePagination',\n                    'templateUrl': '='\n                },\n                replace: false,\n                link: function (scope, element, attrs) {\n\n                    scope.params.settings().$scope.$on('ngTableAfterReloadData', function () {\n                        scope.pages = scope.params.generatePagesArray(scope.params.page(), scope.params.total(), scope.params.count());\n                    }, true);\n\n                    scope.$watch('templateUrl', function (templateUrl) {\n                        if (angular.isUndefined(templateUrl)) {\n                            return;\n                        }\n                        var template = angular.element(document.createElement('div'))\n                        template.attr({\n                            'ng-include': 'templateUrl'\n                        });\n                        element.append(template);\n                        $compile(template)(scope);\n                    });\n                }\n            };\n        }\n    ]);\n    angular.module('ngTable').run(['$templateCache', function ($templateCache) {\n        $templateCache.put('ng-table/filters/select-multiple.html', '<select ng-options=\"data.id as data.title for data in $column.data\" ng-disabled=\"$filterRow.disabled\" multiple ng-multiple=\"true\" ng-model=\"params.filter()[name]\" ng-show=\"filter==\\'select-multiple\\'\" class=\"filter filter-select-multiple form-control\" name=\"{{name}}\"> </select>');\n        $templateCache.put('ng-table/filters/select.html', '<select ng-options=\"data.id as data.title for data in $column.data\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" ng-show=\"filter==\\'select\\'\" class=\"filter filter-select form-control\" name=\"{{name}}\"> </select>');\n        $templateCache.put('ng-table/filters/text.html', '<input type=\"text\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" ng-if=\"filter==\\'text\\'\" class=\"input-filter form-control\"/>');\n        $templateCache.put('ng-table/header.html', '<tr> <th title=\"{{$column.headerTitle(this)}}\" ng-repeat=\"$column in $columns\" ng-class=\"{ \\'sortable\\': $column.sortable(this), \\'sort-asc\\': params.sorting()[$column.sortable(this)]==\\'asc\\', \\'sort-desc\\': params.sorting()[$column.sortable(this)]==\\'desc\\' }\" ng-click=\"sortBy($column, $event)\" ng-show=\"$column.show(this)\" ng-init=\"template=$column.headerTemplateURL(this)\" class=\"header {{$column.class(this)}}\"> <div ng-if=\"!template\" ng-show=\"!template\" class=\"ng-table-header\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'div\\'}\"> <span ng-bind=\"$column.title(this)\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'span\\'}\"></span> </div> <div ng-if=\"template\" ng-show=\"template\" ng-include=\"template\"></div> </th> </tr> <tr ng-show=\"show_filter\" class=\"ng-table-filters\"> <th data-title-text=\"{{$column.titleAlt(this) || $column.title(this)}}\" ng-repeat=\"$column in $columns\" ng-show=\"$column.show(this)\" class=\"filter\"> <div ng-repeat=\"(name, filter) in $column.filter(this)\"> <div ng-if=\"filter.indexOf(\\'/\\') !==-1\" ng-include=\"filter\"></div> <div ng-if=\"filter.indexOf(\\'/\\')===-1\" ng-include=\"\\'ng-table/filters/\\' + filter + \\'.html\\'\"></div> </div> </th> </tr> ');\n        $templateCache.put('ng-table/pager.html', '<div class=\"ng-cloak ng-table-pager\" ng-if=\"params.data.length\">\\n  <ul ng-if=\"params.settings().counts.length\" class=\"ng-table-counts pagination pull-right\">\\n    <li ng-repeat=\"count in params.settings().counts\"\\n        ng-class=\"{\\'active\\':params.count()==count}\"\\n        ng-click=\"params.count(count)\">\\n      <a href=\"\" ng-bind=\"count\"></a>\\n    </li>\\n  </ul>\\n\\n  <ul class=\"pagination ng-table-pagination\">\\n    <li ng-class=\"{\\'disabled\\': !page.active && !page.current, \\'active\\': page.current}\"\\n        ng-repeat=\"page in pages\"\\n        ng-switch=\"page.type\">\\n      <a ng-switch-when=\"prev\" ng-click=\"params.page(page.number)\" href=\"\"><i class=\"md md-chevron-left\"></i></a>\\n      <a ng-switch-when=\"first\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a>\\n      <a ng-switch-when=\"page\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a>\\n      <a ng-switch-when=\"more\" ng-click=\"params.page(page.number)\" href=\"\">&#8230;</a>\\n      <a ng-switch-when=\"last\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a>\\n      <a ng-switch-when=\"next\" ng-click=\"params.page(page.number)\" href=\"\"><i class=\"md md-chevron-right\"></i></a>\\n    </li>\\n  </ul>\\n</div> ');\n    }]);\n    return app;\n}));\n",
    "(function () {\n\n    'use strict';\n\n    angular.module('ui.organisation', [])\n\n        .factory('Tree', function () {\n            function Tree(structure) {\n                forEach(structure, function (node) {\n                    for (var i = 0; node.children && i < node.children.length; i++) {\n                        node.children[i].parent = node;\n                    }\n                });\n\n                this.structure = structure;\n            }\n\n            /*\n             Make tree from organisation where organisation is :\n             [\n             {name:'H1', groups:[{name:'G1, users:['U1','U2']},{}]},\n             {name:'H2': groups:[]\n             ]\n             */\n\n            Tree.fromOrganisation = function (organisation) {\n                var tree;\n\n                function convertUser(userName) {\n                    return {name: userName, type: 'user'};\n                }\n\n                function convertGroup(group) {\n                    var node = {type: 'group', name: group.name, children: []};\n\n                    angular.forEach(group.groups, function (item, name) {\n                        node.children.push(convertGroup(item));\n                    });\n\n                    angular.forEach(group.users, function (item, name) {\n                        node.children.push(convertUser(item));\n                    });\n\n                    return node;\n                }\n\n                function convertGroups(groupsArray) {\n                    var nodes = [];\n\n                    angular.forEach(groupsArray, function (group) {\n                        nodes.push(convertGroup(group));\n                    });\n\n                    return nodes;\n                }\n\n                tree = {type: 'root', name: 'Hierarchies', expanded: true, children: []};\n\n                angular.forEach(organisation, function (hierarchy) {\n                    tree.children.push({\n                        type: 'hierarchy',\n                        children: convertGroups(hierarchy.groups),\n                        name: hierarchy.name\n                    });\n                });\n\n                return new Tree(tree);\n            };\n\n            function shallowCopy(src, dst) {\n                if (angular.isArray(src)) {\n                    dst = dst || [];\n\n                    for (var i = 0; i < src.length; i++) {\n                        dst[i] = src[i];\n                    }\n                } else if (angular.isObject(src)) {\n                    dst = dst || {};\n\n                    for (var key in src) {\n                        if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n                            dst[key] = src[key];\n                        }\n                    }\n                }\n\n                return dst || src;\n            }\n\n            function forEach(node, callback) {\n                var result = null;\n\n                if (!node) {\n                    return;\n                }\n\n                if (typeof callback === 'function') {\n                    callback(node);\n                }\n\n                if (node.children != null) {\n                    for (var i = 0; result === null && i < node.children.length; i++) {\n                        result = forEach(node.children[i], callback);\n                    }\n                }\n\n                return result;\n            }\n\n            function forEachParent(node, callback) {\n                var current = node;\n\n                if (!node) {\n                    return;\n                }\n\n                while (current.parent) {\n                    current = current.parent;\n                    if (typeof callback === 'function') {\n                        callback(current);\n                    }\n                }\n            }\n\n            function searchNode(node, text) {\n                var result = null;\n                var child;\n                var children = [];\n                var regex = new RegExp(text, 'i');\n\n                if (!node) {\n                    return;\n                }\n\n                if (node.children != null) {\n                    for (var i = 0; i < node.children.length; i++) {\n                        child = searchNode(node.children[i], text);\n\n                        if (child !== null) {\n                            children.push(child);\n                        }\n                    }\n                }\n\n                if (node.name.match(regex) || children.length) {\n                    result = shallowCopy(node);\n                    result.expanded = true;\n\n                    if (children.length) {\n                        result.children = children;\n                    }\n                }\n\n                return result;\n            }\n\n            function getFirstNode(node, text) {\n                var result = null;\n                var regex = new RegExp(text, 'i');\n\n                if (!node) {\n                    return null;\n                }\n\n                if (node.name.match(regex)) {\n                    return node;\n                }\n\n                if (node.children != null) {\n                    for (var i = 0; result === null && i < node.children.length; i++) {\n                        result = getFirstNode(node.children[i], text);\n                    }\n                }\n\n                return result;\n            }\n\n            function toArray(node, level) {\n                var result;\n                var child;\n\n                if (!node) {\n                    return;\n                }\n\n                result = [node];\n\n                if (node.children != null) {\n                    for (var i = 0; i < node.children.length; i++) {\n                        child = toArray(node.children[i], level + 1);\n\n                        if (child !== null) {\n                            result = result.concat(child);\n                        }\n                    }\n                }\n\n                return result;\n            }\n\n            Tree.prototype.search = function (text) {\n                return (text ? searchNode(this.structure, text) : this.structure);\n            };\n\n            Tree.prototype.toArray = function () {\n                return toArray(this.structure, 0);\n            };\n\n            Tree.prototype.getNodeInGroup = function (hierarchyName, groupName, nodeName) {\n                var hierarchy = getFirstNode(this.structure, hierarchyName);\n                var group = getFirstNode(hierarchy, groupName);\n                var node = getFirstNode(group, nodeName);\n\n                forEachParent(node || group || hierarchy, function (node) {\n                    node.expanded = true;\n                });\n\n                return node || group || hierarchy;\n            };\n\n            return Tree;\n        })\n\n        .directive('selectOrganisation', function (Tree) {\n            return {\n                restrict: 'AE',\n                require: ['ngModel', '^form'],\n                scope: {\n                    assignee: '=ngModel',\n                    organisation: '=selectOrganisation',\n                    ngDisabled: '=',\n                    requiredSelection: '@'\n                },\n                link: function (scope, element, attrs, controllers) {\n                    var ngModelController = controllers[0];\n                    var formController = controllers[1];\n                    var requiredFields = scope.requiredSelection ? scope.requiredSelection.split(',') : [];\n\n                    scope.$watch('assignee', function (newValue, oldValue) {\n                        var valid = true;\n\n                        if (requiredFields.length) {\n                            angular.forEach(requiredFields, function (fieldName) {\n                                if (!newValue || !newValue[fieldName]) {\n                                    valid = false;\n                                }\n                            });\n\n                            ngModelController.$setValidity('required', valid);\n                        }\n\n                        if (newValue !== oldValue) {\n                            ngModelController.$setDirty();\n                        }\n                    });\n\n                    element.bind('keydown', function (e) {\n                        if (/(40|32)/.test(e.which)) {\n\n                            e.preventDefault();\n                            e.stopPropagation();\n\n                            if (!scope.isDropdownOpen) {\n                                scope.$apply(function () {\n                                    scope.isDropdownOpen = true\n                                });\n                            }\n                        }\n                    });\n\n                    formController.$addControl(ngModelController);\n                },\n                controller: function ($scope, $element) {\n                    var tree;\n                    var selectedNode;\n\n                    function onDblClick(node) {\n                        $scope.isDropdownOpen = false;\n                    }\n\n                    function getIconClass(node) {\n                        return node.type === 'user' ? 'md md-person' : (node.type === 'root' ? 'md md-home' : 'md md-group-work');\n                    }\n\n                    $element.find('input').bind('click', function (evt) {\n                        evt.preventDefault();\n                        evt.stopPropagation();\n                    });\n\n                    $scope.searchTree = function () {\n                        $scope.tree = tree.search($scope.search);\n                    };\n\n                    $scope.$watch('organisation', function (value) {\n                        if (value) {\n                            tree = Tree.fromOrganisation(value);\n                            $scope.searchTree();\n\n                            if ($scope.assignee) {\n                                selectedNode = tree.getNodeInGroup($scope.assignee.hierarchy, $scope.assignee.group, $scope.assignee.user);\n\n                                if (selectedNode) {\n                                    selectedNode.selected = true;\n                                }\n                            }\n                        }\n                    });\n\n                    $scope.options = {\n                        collapsible: true,\n                        showRoot: false,\n                        getIconClass: getIconClass,\n                        nodeClassProperty: 'type',\n                        displayProperty: 'name',\n                        onDblClick: onDblClick\n                    };\n                },\n                templateUrl: 'template/organisation/select-organisation.tpl.html'\n            };\n        })\n\n        .value('treeViewDefaults', {\n            iconClassProperty: 'type',\n            displayProperty: 'name',\n            collapsible: true\n        })\n\n        .directive('treeView', function ($q, treeViewDefaults, Tree) {\n            return {\n                restrict: 'EA',\n                scope: {\n                    treeView: '=',\n                    treeViewOptions: '=',\n                    ngModel: '='\n                },\n                replace: true,\n                template: '<div class=\"tree\"><div tree-view-node=\"treeView\" tabindex=\"-1\"></div></div>',\n                controller: function ($scope, $element) {\n                    var self = this;\n                    var selectedNode;\n                    var options;\n                    var nodes = new Tree($scope.treeView).toArray();\n\n                    options = angular.extend({}, treeViewDefaults, $scope.treeViewOptions);\n\n                    $scope.$watch('treeViewOptions', function (treeViewOptions) {\n                        angular.extend(options, treeViewOptions);\n                    });\n\n                    this.selectNode = function (node) {\n                        selectedNode = node;\n\n                        if (typeof options.onNodeSelect === 'function') {\n                            options.onNodeSelect(node);\n                        }\n\n                        self.updateModel(node);\n                    };\n\n                    this.dblClicked = function (node) {\n                        if (typeof options.onDblClick === 'function') {\n                            options.onDblClick(node);\n                        }\n                    };\n\n                    this.updateModel = function (node) {\n                        var current;\n                        var model = {};\n\n                        model.user = (node.type === 'user' ? node.name : null);\n                        model.group = (node.type === 'group' ? node.name : (node.parent && node.parent.type === 'group' ? node.parent.name : null));\n\n                        current = node;\n\n                        while (current && current.type !== 'hierarchy') {\n                            current = current.parent;\n                        }\n\n                        model.hierarchy = current && current.name;\n\n                        $scope.ngModel = model;\n                    };\n\n                    this.isSelected = function (node) {\n                        return node === selectedNode;\n                    };\n\n                    this.getOptions = function () {\n                        return options;\n                    };\n\n                    this.selectNextNode = function () {\n                        var index = nodes.indexOf(selectedNode);\n\n                        if (index < nodes.length - 1) {\n                            self.selectNode(nodes[index + 1]);\n                        }\n                    };\n\n                    this.selectPreviousNode = function () {\n                        var index = nodes.indexOf(selectedNode);\n\n                        if (index > 0) {\n                            self.selectNode(nodes[index - 1]);\n                        }\n                    };\n\n                    $element.bind('keydown', function (e) {\n                        if (/(38|40|13)/.test(e.which)) {\n\n                            e.preventDefault();\n                            e.stopPropagation();\n\n                            $scope.$apply(function () {\n\n                                switch (e.keyCode) {\n                                    case (13):\n                                        self.dblClicked();\n                                        break;\n                                    case (40):\n                                        self.selectNextNode();\n                                        break;\n                                    case (38):\n                                        self.selectPreviousNode();\n                                        break;\n                                }\n                            });\n                        }\n                    });\n                }\n            };\n        })\n\n        .directive('treeViewNode', ['$q', '$compile', function ($q, $compile) {\n            return {\n                restrict: 'A',\n                require: '^treeView',\n                scope: {\n                    node: '=treeViewNode'\n                },\n                link: function (scope, element, attrs, controller) {\n                    var options = controller.getOptions();\n                    var template;\n\n                    scope.$watch('node', function (node) {\n                        if (node) {\n                            scope.expanded = node.expanded || options.collapsible === false;\n\n                            angular.forEach(node.children, function (child) {\n                                child.parent = scope.node;\n                            });\n\n                            if (node.selected) {\n                                controller.selectNode(node, element);\n                            }\n                        }\n                    });\n\n                    scope.getIconClass = (typeof options.getIconClass === 'function') ? options.getIconClass : function (node) {\n                        return (node[options.iconClassProperty] ? node[options.iconClassProperty] : 'md md-insert-drive-file');\n                    };\n\n                    scope.getNodeClass = (typeof options.getNodeClass === 'function') ? options.getNodeClass : function (node) {\n                        return (node[options.nodeClassProperty] ? node[options.nodeClassProperty] : 'node');\n                    };\n\n                    scope.hasChildren = function () {\n                        return Boolean(scope.node && (scope.node.children && scope.node.children.length));\n                    };\n\n                    scope.selectNode = function (event) {\n                        event.preventDefault();\n\n                        if (options.collapsible) {\n                            scope.expanded = !scope.expanded;\n                        }\n\n                        controller.selectNode(scope.node, element);\n                    };\n\n                    scope.dblClickNode = function (event) {\n                        event.preventDefault();\n                        event.stopPropagation();\n\n                        controller.dblClicked(scope.node);\n                    };\n\n                    scope.isSelected = function (node) {\n                        return controller.isSelected(node);\n                    };\n\n                    template = '<div ng-if=\"node\" class=\"tree-node\" ng-class=\"getNodeClass(node)\">' +\n                        '<div ng-if=\"node.show !== false\" class=\"tree-node-header\" ng-click=\"selectNode($event)\" ng-dblclick=\"dblClickNode($event)\" ng-class=\"{ selected: isSelected(node) }\">' +\n                        '<i ng-class=\"getIconClass(node)\"></i> ' +\n                        '<span class=\"tree-node-name\">{{ node.' + options.displayProperty + ' }}</span> ' +\n                        '</div>' +\n                        '<div class=\"tree-node-content\"' + (options.collapsible ? ' ng-show=\"expanded\"' : '') + '>' +\n                        '<div ng-repeat=\"child in node.children\" tree-view-node=\"child\" tabindex=\"-1\">' +\n                        '</div>' +\n                        '</div>' +\n                        '</div>' +\n                        '<div ng-if=\"!node\" translate class=\"loading\">No items match your query</div>';\n\n                    $compile(template)(scope, function (clone) {\n                        element.append(clone);\n                    });\n                }\n            };\n        }]);\n\n})();\n",
    "/*\n * Custom Scrollbars\n */\n\n(function () {\n\n    'use strict';\n\n    angular\n        .module('ui.scrollbar', [])\n\n        .service('nicescrollService', function () {\n            var ns = {};\n\n            ns.niceScroll = function (selector, color, cursorWidth) {\n                $(selector).niceScroll({\n                    cursorcolor: color,\n                    cursorborder: 0,\n                    cursorborderradius: 0,\n                    cursorwidth: cursorWidth,\n                    bouncescroll: true,\n                    mousescrollstep: 100,\n                    autohidemode: false\n                });\n            };\n\n            return ns;\n        })\n\n        .directive('scrollbar', function (nicescrollService) {\n            return {\n                restrict: 'AE',\n                link: function (scope, element, attrs) {\n                    element.niceScroll({\n                        cursorcolor: attrs['scrollbarColor'] || 'rgba(0,0,0,0.5)',\n                        cursorborder: 0,\n                        cursorborderradius: 0,\n                        cursorwidth: attrs['scrollbarWidth'] || '5px',\n                        bouncescroll: true,\n                        mousescrollstep: 100\n                    });\n                }\n            };\n        })\n\n        .directive('html', function (nicescrollService) {\n            return {\n                restrict: 'E',\n                link: function (scope, element) {\n                    if (!element.hasClass('ismobile')) {\n                        if (!$('.login-content')[0]) {\n                            nicescrollService.niceScroll(element, 'rgba(0,0,0,0.3)', '5px');\n                        }\n                    }\n                }\n            }\n        })\n\n        //Table\n\n        .directive('tableResponsive', function (nicescrollService) {\n            return {\n                restrict: 'C',\n                link: function (scope, element) {\n                    if (!$('html').hasClass('ismobile')) {\n                        nicescrollService.niceScroll(element, 'rgba(0,0,0,0.3)', '5px');\n                    }\n                }\n            }\n        })\n\n        .directive('chosenResults', function (nicescrollService) {\n            return {\n                restrict: 'C',\n                link: function (scope, element) {\n                    if (!$('html').hasClass('ismobile')) {\n                        nicescrollService.niceScroll(element, 'rgba(0,0,0,0.3)', '5px');\n                    }\n                }\n            }\n        })\n\n        .directive('tabNav', function (nicescrollService) {\n            return {\n                restrict: 'C',\n                link: function (scope, element) {\n                    if (!$('html').hasClass('ismobile')) {\n                        nicescrollService.niceScroll(element, 'rgba(0,0,0,0.3)', '1px');\n                    }\n                }\n            }\n        })\n\n        //For custom class\n\n        .directive('cOverflow', function (nicescrollService) {\n            return {\n                restrict: 'C',\n                link: function (scope, element) {\n                    if (!$('html').hasClass('ismobile')) {\n                        nicescrollService.niceScroll(element, 'rgba(0,0,0,0.4)', '5px');\n                    }\n                }\n            }\n        })\n}());\n",
    "(function () {\n\n    'use strict';\n\n    angular.module('ui.search', ['ui.bootstrap.typeahead'])\n        .directive('iqSearch', ['$timeout', function ($timeout) {\n            return {\n                restrict: 'E',\n                template: '<div class=\"search search-{{ theme }}-theme\"\\n ng-class=\"{ \\'search-is-focused\\': model,\\n                 \\'search-is-closed\\': closed }\">\\n    <div class=\"search-container\">\\n        <label class=\"search-label\"><i class=\"md md-search\"></i></label>\\n        <input type=\"text\" class=\"search-input\" \\n               placeholder=\"{{ placeholder }}\"\\n               ng-model=\"model\">\\n        <span class=\"search-cancel\" ng-click=\"clear()\"><i class=\"md md-cancel\"></i></span>\\n    </div>\\n</div>',\n                scope: true,\n\n                compile: function compile(template, attrs) {\n                    var $input = template.find('.search-input');\n\n                    if (attrs.ngEnter) {\n                        $input.attr('ng-enter', attrs.ngEnter);\n                    }\n\n                    angular.forEach(attrs.$attr, function (key, name) {\n                        var rest = key.substring(4);\n\n                        if (name.indexOf('find') == 0) {\n                            $input.attr('typeahead' + rest, attrs[name]);\n                        }\n                    });\n\n                    return function postLink(scope, element, attrs, controller, transclude) {\n                        var $input = element.find('.search-input');\n                        var $label = element.find('.search-label');\n                        var $searchFilter = element.find('.search');\n                        var $searchFilterContainer = element.find('.search-container');\n\n                        scope.find = attrs.find;\n                        scope.findTemplateUrl = attrs.findTemplateUrl;\n                        scope.theme = attrs.theme;\n                        scope.placeholder = attrs.placeholder;\n                        scope.closeWithValue = attrs.closeWithValue;\n\n                        scope.closed = angular.isDefined(attrs.closed);\n\n                        if (angular.isUndefined(scope.theme)) {\n                            scope.theme = 'dark';\n                        }\n\n                        attrs.$observe('filterWidth', function (filterWidth) {\n                            $searchFilterContainer.css({width: filterWidth});\n                        });\n\n                        // Events\n                        $input\n                            .on('blur', function () {\n                                if (angular.isDefined(attrs.closed) && (!$input.val() || scope.closeWithValue)) {\n                                    if (scope.closeWithValue) {\n                                        scope.$apply(function () {\n                                            scope.model = undefined;\n                                        })\n                                    }\n                                    $searchFilter.velocity({\n                                        width: 40\n                                    }, {\n                                        duration: 400,\n                                        easing: 'easeOutQuint',\n                                        queue: false\n                                    });\n\n                                }\n                            });\n\n                        $label.on('click', function () {\n                            if (angular.isDefined(attrs.closed)) {\n                                $searchFilter.velocity({\n                                    width: attrs.filterWidth ? attrs.filterWidth : 240\n                                }, {\n                                    duration: 400,\n                                    easing: 'easeOutQuint',\n                                    queue: false\n                                });\n\n                                $timeout(function () {\n                                    $input.focus();\n                                }, 401);\n                            } else {\n                                $input.focus();\n                            }\n                        });\n\n                        scope.clear = function () {\n                            scope.model = undefined;\n\n                            $input.focus();\n                        };\n                    }\n                }\n            };\n        }]);\n\n}());\n",
    "angular.module('ui.select', [])\n    .directive('selectpicker', function () {\n        return {\n            restrict: 'C',\n            priority: 100,\n            link: function (scope, element, attrs) {\n                element.selectpicker();\n            }\n        };\n    })\n    .directive('tagSelect', function () {\n        return {\n            restrict: 'C',\n            link: function (scope, element, attrs) {\n                element.chosen({\n                    width: '100%',\n                    'allow_single_deselect': true\n                });\n            }\n        }\n    });\n",
    "(function () {\n\n    'use strict';\n\n    angular\n        .module('ui.sidebar', [])\n\n        .run(function ($rootScope, $sidebar) {\n            $rootScope.$on('$stateChangeStart', function () {\n                $sidebar.close();\n            })\n        })\n\n        .directive('sidebarSwitch', function () {\n            return {\n                restrict: 'AE',\n                replace: true,\n                scope: {},\n                link: function (scope, element, attrs) {\n                    var localStorageKey = 'iqui-sidebar-switched';\n\n                    scope.$watch(function () {\n                        return localStorage.getItem(localStorageKey);\n                    }, function (value) {\n                        scope.isOn = value === 'on';\n\n                        if (value === 'on') {\n                            $('body').addClass('toggled sw-toggled');\n                            $('#header').removeClass('sidebar-toggled');\n                        } else {\n                            $('body').removeClass('toggled sw-toggled');\n                        }\n                    });\n\n                    scope.onChange = function () {\n                        localStorage.setItem(localStorageKey, scope.isOn ? 'on' : 'off');\n                    }\n\n                },\n                template: '<div class=\"toggle-switch sidebar-switch\">\\n    <input id=\"tw-switch\" type=\"checkbox\" hidden=\"hidden\" ng-change=\"onChange()\" ng-model=\"isOn\">\\n    <label for=\"tw-switch\" class=\"ts-helper\"></label>\\n</div>'\n            };\n        })\n\n        .factory('$sidebar', function ($rootScope, $document, $timeout, $injector, $controller, $q, $compile, $templateRequest) {\n            var _api = {};\n            var body = $document.find('body').eq(0);\n\n            function _getTemplatePromise(options) {\n                return options.template ? $q.when(options.template) :\n                    $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);\n            }\n\n            function _getResolvePromises(options) {\n                var promisesArr = [];\n\n                angular.forEach(options.resolve, function (value) {\n                    if (angular.isFunction(value)) {\n                        promisesArr.push($q.when($injector.invoke(value)));\n                    } else {\n                        promisesArr.push($q.when(value));\n                    }\n                });\n\n                return promisesArr;\n            }\n\n            function _createScope(options, resolves) {\n                var scope;\n                var ctrlLocals = {};\n                var ctrlInstance;\n                var i;\n\n                options.scope = options.scope || $rootScope;\n\n                scope = options.scope.$new();\n\n                if (options.controller) {\n                    ctrlLocals.$scope = scope;\n\n                    i = 1;\n\n                    angular.forEach(options.resolve, function (value, key) {\n                        ctrlLocals[key] = resolves[i++];\n                    });\n\n                    ctrlInstance = $controller(options.controller, ctrlLocals);\n\n                    if (options.controllerAs) {\n                        scope[options.controllerAs] = ctrlInstance;\n                    }\n                } else {\n                    i = 1;\n\n                    angular.forEach(options.resolve, function (value, key) {\n                        scope[key] = resolves[i++];\n                    });\n                }\n\n                return scope;\n            }\n\n            function _onClickOutside(sidebar) {\n                return function (event) {\n                    if (!$(event.target).closest($(sidebar.element[0])).length) {\n                        $timeout(function () {\n                            sidebar.hide();\n                        });\n                    }\n                }\n            }\n\n            function Sidebar(options) {\n                var _this = this;\n                var resolvePromise;\n\n                options.resolve = options.resolve || {};\n\n                if (!options.template && !options.templateUrl) {\n                    throw new Error('One of template or templateUrl options is required.');\n                }\n\n                resolvePromise = $q.all([_getTemplatePromise(options)].concat(_getResolvePromises(options)));\n\n                resolvePromise\n                    .then(function (resolves) {\n                        var sidebarTemplate = '<aside class=\"sidebar\"></aside>';\n                        var element = angular.element(sidebarTemplate);\n\n                        _this.content = resolves[0];\n\n                        _this.scope = _createScope(options, resolves);\n\n                        _this.scope.$parent.$on('$destroy', function () {\n                            _this.destroy();\n                        });\n\n                        element.html(_this.content);\n\n                        element.addClass(options.side || 'left');\n\n                        _this.element = $compile(element)(_this.scope);\n\n                        body.append(_this.element);\n                    });\n\n                this.options = options;\n\n                this.isHidden = true;\n\n                this.$promise = resolvePromise;\n            }\n\n            Sidebar.prototype.show = function open() {\n                var _this = this;\n                var deferred = $q.defer();\n\n                this.scope.$close = function (data) {\n                    deferred.resolve(data);\n                    _this.hide();\n                };\n\n                this.scope.$dismiss = function (data) {\n                    deferred.reject(data);\n                    _this.hide();\n                };\n\n                this.clickHandler = _onClickOutside(this);\n\n                $document.on('mouseup', this.clickHandler);\n\n                this.element.addClass('toggled');\n\n                this.isHidden = false;\n\n                return deferred.promise;\n            };\n\n            Sidebar.prototype.hide = function () {\n                this.element.removeClass('toggled');\n\n                this.isHidden = true;\n\n                $document.off('mouseup', this.clickHandler);\n            };\n\n            Sidebar.prototype.toggle = function () {\n                if (this.isHidden) {\n                    this.show();\n                } else {\n                    this.hide();\n                }\n            };\n\n            Sidebar.prototype.destroy = function () {\n                this.hide();\n            };\n\n            _api.create = function create(options) {\n                return new Sidebar(options);\n            };\n\n            _api.close = function () {\n                $('#sidebar').removeClass('toggled');\n                $('#header').removeClass('sidebar-toggled');\n                $('#sidebar-trigger').removeClass('open');\n            };\n\n            return _api;\n        });\n\n    /**\n     Deprecated management of jquery sidebar\n     */\n\n    /**\n     TODO Refactor as sidebar directive and service\n     */\n\n    $('body').on('click', '#sidebar-trigger', function (e) {\n\n        var x = $(this).data('trigger');\n        var $sidebar = '#sidebar';\n        var $trigger = '#sidebar-trigger';\n\n        e.preventDefault();\n\n        $(x).toggleClass('toggled');\n        $(this).toggleClass('open');\n        $('#header').toggleClass('sidebar-toggled');\n\n        $('.sub-menu.toggled').not('.active').each(function () {\n            $(this).removeClass('toggled');\n            $(this).find('ul').hide();\n        });\n\n        $('.profile-menu .main-menu').hide();\n\n        //When clicking outside\n        if ($('#header').hasClass('sidebar-toggled')) {\n            $(document).on('click', function (e) {\n                if (($(e.target).closest($sidebar).length === 0) && ($(e.target).closest($trigger).length === 0)) {\n                    setTimeout(function () {\n                        $($sidebar).removeClass('toggled');\n                        $('#header').removeClass('sidebar-toggled');\n                        $($trigger).removeClass('open');\n                    });\n                }\n            });\n        }\n    });\n\n    //Submenu\n    $('body').on('click', '.sub-menu > a', function (e) {\n        e.preventDefault();\n        $(this).next().slideToggle(200);\n        $(this).parent().toggleClass('toggled');\n    });\n\n    $('#sidebar').removeClass('toggled');\n    $('#header').removeClass('sidebar-toggled');\n    $('#sidebar-trigger').removeClass('open');\n\n}());\n\n",
    "(function () {\n\n    'use strict';\n\n    angular\n        .module('ui.toaster', [\n            'ngAnimate',\n            'ngSanitize'])\n\n        .provider('$toaster', function () {\n            var _config;\n\n            _config = {\n                'limit': 3,\n                'tap-to-dismiss': true,\n                'newest-on-top': true,\n                'time-out': 5000,\n                'aggregate': false,\n                'icon-classes': {\n                    error: 'toast-error',\n                    info: 'toast-info',\n                    success: 'toast-success',\n                    warning: 'toast-warning'\n                },\n                'body-output-type': 'trustedHtml', //  'trustedHtml', 'template'\n                'body-template': 'toasterBodyTmpl.html',\n                'icon-class': 'toast-info',\n                'position-class': 'toast-bottom-right',\n                'title-class': 'toast-title',\n                'message-class': 'toast-message'\n            };\n\n            this.config = function (config) {\n                angular.extend(_config, config);\n\n                return this;\n            };\n\n            this.$get = function ($rootScope) {\n                var _api;\n\n                function _handleError(event, title) {\n                    $rootScope.$on(event, function (event, message) {\n                        _show('error', title, message, 0);\n                    });\n                }\n\n                if (_config.errors) {\n                    for (var key in _config.errors) {\n                        if (_config.errors.hasOwnProperty(key)) {\n                            _handleError(key, _config.errors[key]);\n                        }\n                    }\n                }\n\n                function _show(type, title, body, timeout, bodyOutputType) {\n                    if (!body) {\n                        _api.toast = {\n                            type: type,\n                            body: title,\n                            timeout: timeout,\n                            bodyOutputType: bodyOutputType\n                        };\n                    } else {\n                        _api.toast = {\n                            type: type,\n                            title: title,\n                            body: body,\n                            timeout: timeout,\n                            bodyOutputType: bodyOutputType\n                        };\n                    }\n                    $rootScope.$broadcast('toaster-newToast');\n                }\n\n                function _showType(type) {\n                    return function (title, text) {\n                        if (angular.isObject(text)) {\n                            text = JSON.stringify(text);\n                        }\n                        _show(type, title, text, _config['time-out'], 'trustedHtml');\n                    };\n                }\n\n                function _clear() {\n                    $rootScope.$broadcast('toaster-clearToasts');\n                }\n\n                _api = {\n                    show: _show,\n                    alert: _showType('warning'),\n                    warn: _showType('warning'),\n                    warning: _showType('warning'),\n                    error: _showType('error'),\n                    info: _showType('info'),\n                    success: _showType('success'),\n                    clear: _clear,\n                    config: _config\n                };\n\n                return _api;\n            };\n        })\n\n        .directive('toaster', function ($compile, $timeout, $sce, $toaster) {\n            return {\n                replace: true,\n                restrict: 'EA',\n                scope: true,\n                link: function (scope, element, attrs) {\n\n                    var id = 0;\n                    var mergedConfig = $toaster.config;\n\n                    if (attrs.toasterOptions) {\n                        mergedConfig = angular.extend({}, $toaster.config, scope.$eval(attrs.toasterOptions));\n                    }\n\n                    scope.config = {\n                        position: mergedConfig['position-class'],\n                        title: mergedConfig['title-class'],\n                        message: mergedConfig['message-class'],\n                        tap: mergedConfig['tap-to-dismiss']\n                    };\n\n                    scope.configureTimer = function configureTimer(toast) {\n                        var timeout = typeof (toast.timeout) === 'number' ? toast.timeout : mergedConfig['time-out'];\n                        if (timeout > 0) {\n                            toast.timeout = $timeout(function () {\n                                scope.removeToast(toast.id);\n                            }, timeout);\n                        }\n                    };\n\n                    function addToast(toast) {\n                        toast.type = mergedConfig['icon-classes'][toast.type];\n                        if (!toast.type) {\n                            toast.type = mergedConfig['icon-class'];\n                        }\n\n                        id++;\n                        angular.extend(toast, {id: id});\n\n                        // Set the toast.bodyOutputType to the default if it isn't set\n                        toast.bodyOutputType = toast.bodyOutputType || mergedConfig['body-output-type'];\n                        switch (toast.bodyOutputType) {\n                            case 'trustedHtml':\n                                toast.html = $sce.trustAsHtml(toast.body);\n                                break;\n                            case 'template':\n                                toast.bodyTemplate = toast.body || mergedConfig['body-template'];\n                                break;\n                        }\n\n                        scope.configureTimer(toast);\n\n                        if (mergedConfig['newest-on-top'] === true) {\n                            scope.toasters.unshift(toast);\n                            if (mergedConfig.limit > 0 && scope.toasters.length > mergedConfig.limit) {\n                                scope.toasters.pop();\n                            }\n                        } else {\n                            scope.toasters.push(toast);\n                            if (mergedConfig.limit > 0 && scope.toasters.length > mergedConfig.limit) {\n                                scope.toasters.shift();\n                            }\n                        }\n                    }\n\n                    scope.toasters = [];\n                    scope.$on('toaster-newToast', function () {\n                        if (!mergedConfig.aggregate || scope.toasters.length === 0) {\n                            addToast($toaster.toast);\n                        }\n                    });\n\n                    scope.$on('toaster-clearToasts', function () {\n                        scope.toasters.splice(0, scope.toasters.length);\n                    });\n                },\n                controller: function ($scope) {\n\n                    $scope.stopTimer = function (toast) {\n                        if (toast.timeout) {\n                            $timeout.cancel(toast.timeout);\n                            toast.timeout = null;\n                        }\n                    };\n\n                    $scope.restartTimer = function (toast) {\n                        if (!toast.timeout) {\n                            $scope.configureTimer(toast);\n                        }\n                    };\n\n                    $scope.removeToast = function (id) {\n                        var i = 0;\n                        for (i; i < $scope.toasters.length; i++) {\n                            if ($scope.toasters[i].id === id) {\n                                break;\n                            }\n                        }\n                        $scope.toasters.splice(i, 1);\n                    };\n\n                    $scope.remove = function (id) {\n                        if ($scope.config.tap === true) {\n                            $scope.removeToast(id);\n                        }\n                    };\n                },\n                template: '<div  id=\"toast-container\" ng-class=\"config.position\">' +\n                '<div ng-repeat=\"toaster in toasters\" class=\"toast\" ng-class=\"toaster.type\" ng-click=\"remove(toaster.id)\" ng-mouseover=\"stopTimer(toaster)\"  ng-mouseout=\"restartTimer(toaster)\">' +\n                '<div ng-class=\"config.title\">{{toaster.title}}</div>' +\n                '<div ng-class=\"config.message\" ng-switch on=\"toaster.bodyOutputType\">' +\n                '<div ng-switch-when=\"trustedHtml\" ng-bind-html=\"toaster.html\"></div>' +\n                '<div ng-switch-when=\"template\"><div ng-include=\"toaster.bodyTemplate\"></div></div>' +\n                '<div ng-switch-default >{{toaster.body}}</div>' +\n                '</div>' +\n                '</div>' +\n                '</div>'\n            };\n        })\n\n}());\n",
    "/*\n TODO Refactor as Angular directives and services\n */\n\n\n/*\n * Top Search\n */\n(function () {\n    $('body').on('click', '#top-search > a', function (e) {\n        e.preventDefault();\n\n        $('#top-search-wrap > input').focus();\n\n        $('#header').addClass('search-toggled');\n\n        $('#top-search-wrap > input').keydown(function (e) {\n            if (e.keyCode == 27) {\n                $('#header').removeClass('search-toggled');\n                e.stopPropagation();\n            }\n        });\n    });\n\n    $('body').on('click', '#top-search-close', function (e) {\n        e.preventDefault();\n\n        $('#header').removeClass('search-toggled');\n    });\n})();\n",
    "(function () {\n\n    'use strict';\n\n    var _i18n = window['IQ_I18N'] || {pl: {}};\n\n    angular\n        .module('ui.translate', ['ui.toaster'])\n\n        .factory('$i18n', function () {\n            return _i18n;\n        })\n\n        .provider('$translate', function () {\n            var _language = 'pl';\n\n            this.language = function (language) {\n                _language = language;\n\n                return this;\n            };\n\n            this.$get = function () {\n\n                function translate(key) {\n                    var value;\n\n                    if (!angular.isDefined(key) || key === null) {\n                        return '';\n                    }\n\n                    if (typeof key.trim === 'function') {\n                        key = key.trim();\n                    }\n\n                    value = _i18n[_language][key];\n\n                    return value ? value : key;\n                }\n\n                return translate;\n            };\n        })\n\n        .filter('translate', function ($translate) {\n            return function (value) {\n                return $translate(value);\n            };\n        })\n\n        .directive('translate', function ($translate) {\n            return {\n                restrict: 'AE',\n                link: function (scope, element, attrs) {\n                    element.html($translate(element.html()));\n                }\n            };\n        })\n\n        .factory('$format', function ($translate) {\n\n            function formatString() {\n                var format = arguments[0];\n                var params = Array.prototype.slice.call(arguments, 1);\n                var message;\n\n                format = $translate(format);\n\n                message = format.replace(/{(\\d+)}/g, function (match, number) {\n                    var replacement = 'No value';\n\n                    if (typeof(params[number]) === 'undefined') {\n                        replacement = match;\n                    } else if (params[number] === null) {\n                        replacement = '(' + $translate('No value') + ')';\n                    } else {\n                        replacement = $translate(params[number]);\n                    }\n\n                    return replacement;\n                });\n\n                return message;\n            }\n\n            return formatString;\n        })\n\n        .factory('$toast', function ($toaster, $format) {\n\n            function show(type) {\n                var toasterFn = $toaster[type];\n\n                return function () {\n                    var message = $format.apply(this, arguments);\n                    var colon = message.indexOf(':');\n\n                    message = message.slice(0, colon + 1) + '<strong>' + message.slice(colon + 1) + '</strong>';\n\n                    toasterFn.call(null, message);\n                }\n            }\n\n            return {\n                error: show('error'),\n                info: show('info'),\n                warn: show('warn'),\n                success: show('success')\n            };\n        })\n\n}());\n",
    "(function () {\n\n    'use strict';\n\n    angular\n        .module('ui.utils', [])\n\n    /**\n     * Service for scrolling window\n     */\n        .factory('$scroll', function () {\n            var _api = {};\n\n            _api.toBottom = function () {\n                window.scrollTo(0, document.body.scrollHeight);\n            };\n\n            _api.toTop = function () {\n                window.scrollTo(0, 0);\n            };\n\n            return _api;\n        })\n\n    /**\n     * Service for formatting Bytes using MB, GB, B, KB etc.\n     *\n     * @method filesize\n     * @param  {Mixed}   arg        String, Int or Float to transform\n     * @param  {Object}  descriptor [Optional] Flags\n     * @return {String}             Readable file size String\n     *\n     * Descriptor:\n     *\n     * base (number) Number base, default is 2\n     * bits (boolean) Enables bit sizes, default is false\n     * exponent (number) Specifies the SI suffix via exponent, e.g. 2 is MB for bytes, default is -1\n     * output (string) Output of function (array, exponent, object, or string), default is string\n     * round (number) Decimal place, default is 2\n     * spacer (string) Character between the result and suffix, default is \" \"\n     * suffixes (object) Dictionary of SI suffixes to replace for localization, defaults to english if no match is found\n     * unix (boolean) Enables unix style human readable output, e.g ls -lh, default is false\n     */\n        .factory('$fileSize', function () {\n            var bit = /b$/;\n            var si = {\n                bits: ['B', 'kb', 'Mb', 'Gb', 'Tb', 'Pb', 'Eb', 'Zb', 'Yb'],\n                bytes: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n            };\n\n            function fileSize(arg) {\n                var descriptor = arguments[1] === undefined ? {} : arguments[1];\n\n                var result = [];\n                var skip = false;\n                var val = 0;\n                var e = undefined;\n                var base = undefined;\n                var bits = undefined;\n                var ceil = undefined;\n                var neg = undefined;\n                var num = undefined;\n                var output = undefined;\n                var round = undefined;\n                var unix = undefined;\n                var spacer = undefined;\n                var suffixes = undefined;\n\n                if (isNaN(arg)) {\n                    throw new Error('Invalid arguments');\n                }\n\n                bits = descriptor.bits === true;\n                unix = descriptor.unix === true;\n                base = descriptor.base !== undefined ? descriptor.base : 2;\n                round = descriptor.round !== undefined ? descriptor.round : unix ? 1 : 2;\n                spacer = descriptor.spacer !== undefined ? descriptor.spacer : unix ? '' : ' ';\n                suffixes = descriptor.suffixes !== undefined ? descriptor.suffixes : {};\n                output = descriptor.output !== undefined ? descriptor.output : 'string';\n                e = descriptor.exponent !== undefined ? descriptor.exponent : -1;\n                num = Number(arg);\n                neg = num < 0;\n                ceil = base > 2 ? 1000 : 1024;\n\n                // Flipping a negative number to determine the size\n                if (neg) {\n                    num = -num;\n                }\n\n                // Zero is now a special case because bytes divide by 1\n                if (num === 0) {\n                    result[0] = 0;\n\n                    if (unix) {\n                        result[1] = '';\n                    } else {\n                        result[1] = 'B';\n                    }\n                } else {\n                    // Determining the exponent\n                    if (e === -1 || isNaN(e)) {\n                        e = Math.floor(Math.log(num) / Math.log(ceil));\n                    }\n\n                    // Exceeding supported length, time to reduce & multiply\n                    if (e > 8) {\n                        val = val * (1000 * (e - 8));\n                        e = 8;\n                    }\n\n                    if (base === 2) {\n                        val = num / Math.pow(2, e * 10);\n                    } else {\n                        val = num / Math.pow(1000, e);\n                    }\n\n                    if (bits) {\n                        val = val * 8;\n\n                        if (val > ceil) {\n                            val = val / ceil;\n                            e++;\n                        }\n                    }\n\n                    result[0] = Number(val.toFixed(e > 0 ? round : 0));\n                    result[1] = si[bits ? 'bits' : 'bytes'][e];\n\n                    if (!skip && unix) {\n                        if (bits && bit.test(result[1])) {\n                            result[1] = result[1].toLowerCase();\n                        }\n\n                        result[1] = result[1].charAt(0);\n\n                        if (result[1] === 'B') {\n                            result[0] = Math.floor(result[0]);\n                            result[1] = '';\n                        } else if (!bits && result[1] === 'k') {\n                            result[1] = 'K';\n                        }\n                    }\n                }\n\n                // Decorating a 'diff'\n                if (neg) {\n                    result[0] = -result[0];\n                }\n\n                // Applying custom suffix\n                result[1] = suffixes[result[1]] || result[1];\n\n                // Returning Array, Object, or String (default)\n                if (output === 'array') {\n                    return result;\n                }\n\n                if (output === 'exponent') {\n                    return e;\n                }\n\n                if (output === 'object') {\n                    return {value: result[0], suffix: result[1]};\n                }\n\n                return result.join(spacer);\n            }\n\n            return fileSize;\n        })\n\n        .filter('fileSize', function ($fileSize) {\n            return function (value, config) {\n                return value ? $fileSize(value, config) : '';\n            };\n        })\n\n        /*\n         Directive for indeteriminate checkbox value\n         */\n\n        .directive('indeterminate', function () {\n            return {\n                require: '?ngModel',\n                link: function (scope, element, attrs, ngModelCtrl) {\n                    ngModelCtrl.$formatters = [];\n                    ngModelCtrl.$parsers = [];\n\n                    ngModelCtrl.$render = function () {\n                        var value = ngModelCtrl.$viewValue;\n\n                        element.data('checked', value);\n\n                        switch (value) {\n                            case true:\n                                element.prop('indeterminate', false);\n                                element.prop('checked', true);\n                                break;\n                            case false:\n                                element.prop('indeterminate', false);\n                                element.prop('checked', false);\n                                break;\n                            default:\n                                element.prop('indeterminate', true);\n                        }\n                    };\n\n                    element.bind('click', function () {\n                        var value;\n\n                        switch (element.data('checked')) {\n                            case false:\n                                value = true;\n                                break;\n                            case true:\n                                value = null;\n                                break;\n                            default:\n                                value = false;\n                        }\n                        ngModelCtrl.$setViewValue(value);\n\n                        scope.$apply(ngModelCtrl.$render);\n                    });\n                }\n            };\n        })\n\n        .directive('btnWave', function () {\n            return {\n                restrict: 'C',\n                link: function (scope, element) {\n                    Waves.attach(element);\n                    Waves.init();\n                }\n            }\n        })\n\n        .directive('btn', function ($timeout) {\n            return {\n                restrict: 'C',\n                link: function (scope, element) {\n                    if (!element.is('input') && !element.hasClass('no-waves')) {\n                        if (element.is('a') || element.hasClass('btn-link')) {\n                            element.addClass('waves-effect waves-button');\n                        } else {\n                            element.addClass('waves-effect');\n                        }\n                    }\n\n                    $timeout(function () {\n                        Waves.init();\n                    });\n                }\n            }\n        })\n\n        .directive('fgLine', function () {\n            return {\n                restrict: 'C',\n                link: function (scope, element) {\n                    if ($('.fg-line')[0]) {\n                        $('body').on('focus', '.form-control', function () {\n                            $(this).closest('.fg-line').addClass('fg-toggled');\n                        });\n\n                        $('body').on('blur', '.form-control', function () {\n                            var p = $(this).closest('.form-group');\n                            var i = p.find('.form-control').val();\n\n                            if (p.hasClass('fg-float')) {\n                                if (i.length == 0) {\n                                    $(this).closest('.fg-line').removeClass('fg-toggled');\n                                }\n                            }\n                            else {\n                                $(this).closest('.fg-line').removeClass('fg-toggled');\n                            }\n                        });\n                    }\n\n                }\n            }\n\n        })\n\n        .directive('autosize', function ($timeout) {\n            return {\n                restrict: 'A',\n                link: function (scope, element, attrs) {\n                    $timeout(function () {\n                        element.autosize();\n                    });\n                }\n            };\n        })\n\n        .directive('tagSelect', function () {\n            return {\n                restrict: 'A',\n                link: function (scope, element) {\n                    if (element[0]) {\n                        element.chosen({\n                            width: '100%',\n                            'allow_single_deselect': true\n                        });\n                    }\n                }\n            }\n        })\n\n        .directive('toggleSwitch', function () {\n            var id = 1;\n\n            return {\n                restrict: 'AE',\n                replace: true,\n                transclude: true,\n                scope: {\n                    ngModel: '=',\n                    ngChange: '&',\n                    ngDisabled: '=',\n                    name: '@',\n                    on:'@',\n                    off:'@'\n                },\n                link: function (scope, element, attrs) {\n                    scope.id = id++;\n                },\n                template: '<div class=\"toggle-switch\" ng-class=\"{active: ngModel}\">\\n    <label for=\"toggle-{{ id }}\" ng-if=\"!off && !on\" class=\"ts-label\" ng-transclude> </label>\\n    <label for=\"toggle-{{ id }}\" ng-if=\"off\" class=\"ts-label before\" > {{ off }}</label>\\n    \\n    <input id=\"toggle-{{ id }}\" type=\"checkbox\" hidden=\"hidden\" name=\"{{ name }}\" ng-model=\"ngModel\" ng-disabled=\"ngDisabled\" ng-change=\"ngChange()\">\\n    <label for=\"toggle-{{ id }}\" class=\"ts-helper\"></label>\\n    \\n    <label for=\"toggle-{{ id }}\" ng-if=\"on\" class=\"ts-label after\" > {{ on }}</label>\\n</div>'\n            };\n        })\n\n        .directive('navTabs', function () {\n            return {\n                restrict: 'C',\n                link: function (scope, element, attrs) {\n                    element.addClass('tab-nav');\n                }\n            };\n        })\n\n        .directive('errSrc', function () {\n            return {\n                link: function (scope, element, attrs) {\n                    scope.$watch(function () {\n                        return attrs['ngSrc'];\n                    }, function (value) {\n                        if (!value) {\n                            element.attr('src', attrs.errSrc);\n                        }\n                    });\n\n                    element.bind('error', function () {\n                        element.attr('src', attrs.errSrc);\n                    });\n                }\n            }\n        })\n\n        .directive('prettyCode', function ($timeout) {\n            return {\n                restrict: 'AE',\n                transclude: true,\n                replace: true,\n                link: function (scope, element, attrs) {\n                    var codeElement = element.find('code')[0];\n\n                    if (!window.prettyPrintOne) {\n                        return;\n                    }\n\n                    $timeout(function () {\n                        codeElement.innerHTML = window.prettyPrintOne(codeElement.innerText)\n                    });\n                },\n                template: '<pre class=\"prettyprint\"><code class=\"language-yaml\" ng-transclude></code></pre>'\n            };\n        })\n\n        .directive('fileUpload', function ($utils) {\n            return {\n                restrict: 'E',\n                template: '<div class=\"fileinput\">\\n    <div class=\"btn btn-primary btn-file\">\\n        <span class=\"fileinput-label\">Wybierz plik</span>\\n        <input type=\"hidden\" value=\"\" name=\"...\">\\n        <input type=\"file\" name=\"\">\\n    </div>\\n    <div class=\"fileinput-fileinfo alert alert-info alert-dismissible\" ng-show=\"file\">\\n        <button type=\"button\" class=\"close\" ng-click=\"clear()\"><span aria-hidden=\"true\">&times;</span></button>\\n        \\n        <dl class=\"dl-horizontal\">\\n            <dt>Nazwa: </dt>\\n            <dd>{{ file.name}}</dd>\\n            <dt>Wielko: </dt>\\n            <dd>{{ file.size | fileSize}}</dd>\\n            <dt>Typ: </dt>\\n            <dd>{{ file.type }}</dd>\\n        </dl>\\n    </div>\\n    \\n</div>',\n                require: 'ngModel',\n                scope: {\n                    validate: '&',\n                    file: '=ngModel'\n                },\n                replace: true,\n                link: function (scope, element, attr, ctrl) {\n                    var input;\n\n                    input = element.find('input');\n\n                    if (typeof scope.validate !== 'function') {\n                        scope.validate = function () {\n                            return true\n                        };\n                    }\n\n                    var listener = function () {\n                        scope.$apply(function () {\n                            var file = input[1].files[0];\n\n                            if (file && scope.validate({$file: file})) {\n                                scope.file = file;\n                            }\n                        });\n                    };\n\n                    input.bind('change', listener);\n\n                    scope.clear = function () {\n                        scope.file = undefined;\n                    };\n                }\n            }\n        })\n\n        .directive('ngEnter', function () {\n            return function (scope, element, attrs) {\n                element.bind('keydown keypress', function (event) {\n                    if (event.which === 13) {\n                        scope.$apply(function () {\n                            scope.$eval(attrs.ngEnter, {'event': event});\n                        });\n\n                        event.preventDefault();\n                    }\n                });\n            };\n        })\n\n        .directive('ngEscape', function ($document) {\n            var handlers = [];\n\n            function unbind(handler) {\n                $document.unbind('keydown keypress', handler);\n            }\n\n            function bind(handler) {\n                var handlersCount = handlers.length;\n\n                if (handlersCount > 0) {\n                    unbind(handlers[handlersCount - 1]);\n                }\n\n                $document.bind('keydown keypress', handler);\n\n                handlers.push(handler);\n            }\n\n            return function (scope, element, attrs) {\n                function clickHandler(event) {\n                    if (event.which === 27) {\n                        scope.$apply(function () {\n                            scope.$eval(attrs.ngEscape, {'event': event});\n                        });\n\n                        event.preventDefault();\n                    }\n                }\n\n                bind(clickHandler);\n\n                scope.$on('$destroy', function () {\n                    unbind(clickHandler);\n                    handlers.pop();\n                    bind(handlers[handlers.length - 1]);\n                });\n            };\n        })\n\n        .directive('spinner', function () {\n            return {\n                restrict: 'AE',\n                replace: true,\n                template: '<div class=\"spinner spinner-wave\">\\n          <div class=\"rect1\"></div>\\n          <div class=\"rect2\"></div>\\n          <div class=\"rect3\"></div>\\n          <div class=\"rect4\"></div>\\n          <div class=\"rect5\"></div>\\n        </div>'\n            };\n        })\n\n        .directive('radioButton', function () {\n            return {\n                restrict: 'AE',\n                transclude: true,\n                replace: true,\n                scope: {\n                    ngModel: '=',\n                    value: '@'\n                },\n                controller: function ($scope, $element, $attrs) {\n                },\n                link: function (scope, element, attrs) {\n                },\n                template: '<label class=\"radio\">' +\n                '<input type=\"radio\" name=\"radioGroup\" ' +\n                'value=\"{{value}}\" data-toggle=\"radio\" ' +\n                'ng-model=\"ngModel\" class=\"custom-radio\">' +\n                '<span class=\"icons\">' +\n                '<span class=\"icon-unchecked\"></span>' +\n                '<span class=\"icon-checked\"></span>' +\n                '</span>' +\n\n                '<span ng-transclude></span>' +\n                '</label>'\n            };\n        })\n\n}());\n",
    "angular.module('ui.templates', ['template/datetimepicker/datepicker.tpl.html', 'template/datetimepicker/datetimepicker.html', 'template/datetimepicker/timepicker.tpl.html', 'template/datetimepicker/tooltip.tpl.html', 'template/organisation/select-organisation.tpl.html', 'template/tabs/tabset.html']);\n\nangular.module('template/datetimepicker/datepicker.tpl.html', []).run(['$templateCache', function($templateCache) {\n  'use strict';\n  $templateCache.put('template/datetimepicker/datepicker.tpl.html',\n    '<div class=\"dropdown-menu datepicker\" ng-class=\"\\'datepicker-mode-\\' + $mode\" style=\"max-width: 210px;\">\\n' +\n    '    <table style=\"table-layout: fixed; height: 100%; width: 100%;\">\\n' +\n    '        <thead>\\n' +\n    '        <tr class=\"text-center\">\\n' +\n    '            <th>\\n' +\n    '                <button tabindex=\"-1\" type=\"button\" class=\"btn btn-link pull-left\" ng-click=\"$selectPane(-1)\">\\n' +\n    '                    <i class=\"{{$iconLeft}}\"></i>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '            <th colspan=\"{{ rows[0].length - 2 }}\">\\n' +\n    '                <button tabindex=\"-1\" type=\"button\" class=\"btn btn-link btn-block text-strong\"\\n' +\n    '                        ng-click=\"$toggleMode()\">\\n' +\n    '                    <strong style=\"text-transform: capitalize;\" ng-bind=\"title\"></strong>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                <button tabindex=\"-1\" type=\"button\" class=\"btn btn-link pull-right\" ng-click=\"$selectPane(+1)\">\\n' +\n    '                    <i class=\"{{$iconRight}}\"></i>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '        </tr>\\n' +\n    '        <tr ng-show=\"showLabels\" ng-bind-html=\"labels\"></tr>\\n' +\n    '        </thead>\\n' +\n    '        <tbody>\\n' +\n    '        <tr ng-repeat=\"(i, row) in rows\" height=\"{{ 100 / rows.length }}%\">\\n' +\n    '            <td class=\"text-center\" ng-repeat=\"(j, el) in row\">\\n' +\n    '                <button tabindex=\"-1\" type=\"button\" class=\"btn btn-link btn-sm\"\\n' +\n    '                        ng-class=\"{\\'btn-primary\\': el.selected, \\'btn-info btn-today\\': el.isToday && !el.selected}\"\\n' +\n    '                        ng-click=\"$select(el.date)\" ng-disabled=\"el.disabled\">\\n' +\n    '                    <span ng-class=\"{\\'text-muted\\': el.muted}\" ng-bind=\"el.label\"></span>\\n' +\n    '                </button>\\n' +\n    '            </td>\\n' +\n    '        </tr>\\n' +\n    '        </tbody>\\n' +\n    '    </table>\\n' +\n    '\\n' +\n    '    <div style=\"padding:10px 0px 20px 0px\">\\n' +\n    '\t\t<span class=\"pull-left\">\\n' +\n    '\t\t\t<button type=\"button\" class=\"btn btn-icon\" tabindex=\"-1\" ng-click=\"$today()\" tooltip=\"Dzi\" tooltip-placement=\"bottom\"><i class=\"md md-event c-blue\"></i></button>\\n' +\n    '\t\t\t<button type=\"button\" class=\"btn btn-icon\" tabindex=\"-1\" ng-click=\"$clear()\" tooltip=\"Kasuj\" tooltip-placement=\"bottom\"><i class=\"md md-clear c-red\"></i></button>\\n' +\n    '\t\t</span>\\n' +\n    '        <button type=\"button\" class=\"btn btn-icon pull-right\"  tabindex=\"-1\" ng-click=\"$close()\" tooltip=\"Zamknij\" tooltip-placement=\"bottom\"><i class=\"md md-done c-green\"></i></button>\\n' +\n    '    </div>\\n' +\n    '</div>\\n' +\n    '');\n}]);\n\nangular.module('template/datetimepicker/datetimepicker.html', []).run(['$templateCache', function($templateCache) {\n  'use strict';\n  $templateCache.put('template/datetimepicker/datetimepicker.html',\n    '<div class=\"datetimepicker form-inline\">\\n' +\n    '\\n' +\n    '    <div class=\"form-group\">\\n' +\n    '        <input type=\"text\"\\n' +\n    '               class=\"date form-control\"\\n' +\n    '               size=\"11\"\\n' +\n    '               ng-model=\"ngModel\"\\n' +\n    '               is-dirty=\"{{ isDirty }}\"\\n' +\n    '               min-date=\"{{ minDate }}\"\\n' +\n    '               max-date=\"{{ maxDate }}\"\\n' +\n    '               placeholder=\"{{ dateFormat }}\"\\n' +\n    '               bs-datepicker>\\n' +\n    '    </div>\\n' +\n    '\\n' +\n    '\\n' +\n    '    <div class=\"form-group\">\\n' +\n    '        <input type=\"text\"\\n' +\n    '               class=\"time form-control\"\\n' +\n    '               size=\"8\"\\n' +\n    '               ng-change=\"touchDate()\"\\n' +\n    '               ng-model=\"ngModel\"\\n' +\n    '               ng-show=\"!dateOnly\"\\n' +\n    '               placeholder=\"{{ timeFormat }}\"\\n' +\n    '               bs-timepicker>\\n' +\n    '    </div>\\n' +\n    '\\n' +\n    '</div>\\n' +\n    '');\n}]);\n\nangular.module('template/datetimepicker/timepicker.tpl.html', []).run(['$templateCache', function($templateCache) {\n  'use strict';\n  $templateCache.put('template/datetimepicker/timepicker.tpl.html',\n    '<div class=\"dropdown-menu timepicker\" style=\"min-width: 0px;width: auto;\">\\n' +\n    '    <table height=\"100%\">\\n' +\n    '        <thead>\\n' +\n    '        <tr class=\"text-center\">\\n' +\n    '            <th>\\n' +\n    '                <button tabindex=\"-1\" type=\"button\" class=\"btn btn-link pull-left no-waves\" ng-click=\"$arrowAction(-1, 0)\">\\n' +\n    '                    <i class=\"{{ $iconUp }}\"></i>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                &nbsp;\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                <button tabindex=\"-1\" type=\"button\" class=\"btn btn-link pull-left no-waves\" ng-click=\"$arrowAction(-1, 1)\">\\n' +\n    '                    <i class=\"{{ $iconUp }}\"></i>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                &nbsp;\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                <button ng-if=\"showSeconds\" tabindex=\"-1\" type=\"button\" class=\"btn btn-link pull-left no-waves\"\\n' +\n    '                        ng-click=\"$arrowAction(-1, 2)\">\\n' +\n    '                    <i class=\"{{ $iconUp }}\"></i>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '        </tr>\\n' +\n    '        </thead>\\n' +\n    '        <tbody>\\n' +\n    '        <tr ng-repeat=\"(i, row) in rows\">\\n' +\n    '            <td class=\"text-center\">\\n' +\n    '                <button tabindex=\"-1\"  type=\"button\" class=\"btn btn-link btn-sm\"\\n' +\n    '                        ng-class=\"{\\'btn-primary\\': row[0].selected}\" ng-click=\"$select(row[0].date, 0)\"\\n' +\n    '                        ng-disabled=\"row[0].disabled\">\\n' +\n    '                    <span ng-class=\"{\\'text-muted\\': row[0].muted}\" ng-bind=\"row[0].label\"></span>\\n' +\n    '                </button>\\n' +\n    '            </td>\\n' +\n    '            <td>\\n' +\n    '                <span ng-bind=\"i == midIndex ? timeSeparator : \\' \\'\"></span>\\n' +\n    '            </td>\\n' +\n    '            <td class=\"text-center\">\\n' +\n    '                <button tabindex=\"-1\" ng-if=\"row[1].date\"  type=\"button\" class=\"btn btn-link btn-sm\"\\n' +\n    '                        ng-class=\"{\\'btn-primary\\': row[1].selected}\" ng-click=\"$select(row[1].date, 1)\"\\n' +\n    '                        ng-disabled=\"row[1].disabled\">\\n' +\n    '                    <span ng-class=\"{\\'text-muted\\': row[1].muted}\" ng-bind=\"row[1].label\"></span>\\n' +\n    '                </button>\\n' +\n    '            </td>\\n' +\n    '            <td>\\n' +\n    '                <span ng-bind=\"i == midIndex ? timeSeparator : \\' \\'\"></span>\\n' +\n    '            </td>\\n' +\n    '            <td class=\"text-center\">\\n' +\n    '                <button tabindex=\"-1\" ng-if=\"showSeconds && row[2].date\"  type=\"button\"\\n' +\n    '                        class=\"btn btn-link btn-sm\" ng-class=\"{\\'btn-primary\\': row[2].selected}\"\\n' +\n    '                        ng-click=\"$select(row[2].date, 2)\" ng-disabled=\"row[2].disabled\">\\n' +\n    '                    <span ng-class=\"{\\'text-muted\\': row[2].muted}\" ng-bind=\"row[2].label\"></span>\\n' +\n    '                </button>\\n' +\n    '            </td>\\n' +\n    '            <td ng-if=\"showAM\">\\n' +\n    '                &nbsp;\\n' +\n    '            </td>\\n' +\n    '            <td ng-if=\"showAM\">\\n' +\n    '                <button tabindex=\"-1\" ng-show=\"i == midIndex - !isAM * 1\"  type=\"button\"\\n' +\n    '                        ng-class=\"{\\'btn-primary\\': !!isAM}\" class=\"btn btn-link btn-sm\" ng-click=\"$switchMeridian()\"\\n' +\n    '                        ng-disabled=\"el.disabled\">AM\\n' +\n    '                </button>\\n' +\n    '                <button tabindex=\"-1\" ng-show=\"i == midIndex + 1 - !isAM * 1\"  type=\"button\"\\n' +\n    '                        ng-class=\"{\\'btn-primary\\': !isAM}\" class=\"btn btn-link btn-sm\" ng-click=\"$switchMeridian()\"\\n' +\n    '                        ng-disabled=\"el.disabled\">PM\\n' +\n    '                </button>\\n' +\n    '            </td>\\n' +\n    '        </tr>\\n' +\n    '        </tbody>\\n' +\n    '        <tfoot>\\n' +\n    '        <tr class=\"text-center\">\\n' +\n    '            <th>\\n' +\n    '                <button tabindex=\"-1\" type=\"button\" class=\"btn btn-link  pull-left no-waves\" ng-click=\"$arrowAction(1, 0)\">\\n' +\n    '                    <i class=\"{{ $iconDown }}\"></i>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                &nbsp;\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                <button tabindex=\"-1\" type=\"button\" class=\"btn btn-link  pull-left no-waves\" ng-click=\"$arrowAction(1, 1)\">\\n' +\n    '                    <i class=\"{{ $iconDown }}\"></i>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                &nbsp;\\n' +\n    '            </th>\\n' +\n    '            <th>\\n' +\n    '                <button ng-if=\"showSeconds\" tabindex=\"-1\" type=\"button\" class=\"btn btn-link  pull-left no-waves\"\\n' +\n    '                        ng-click=\"$arrowAction(1, 2)\">\\n' +\n    '                    <i class=\"{{ $iconDown }}\"></i>\\n' +\n    '                </button>\\n' +\n    '            </th>\\n' +\n    '        </tr>\\n' +\n    '        </tfoot>\\n' +\n    '    </table>\\n' +\n    '</div>\\n' +\n    '');\n}]);\n\nangular.module('template/datetimepicker/tooltip.tpl.html', []).run(['$templateCache', function($templateCache) {\n  'use strict';\n  $templateCache.put('template/datetimepicker/tooltip.tpl.html',\n    '<div class=\"tooltip in\" ng-show=\"title\">\\n' +\n    '  <div class=\"tooltip-arrow\"></div>\\n' +\n    '  <div class=\"tooltip-inner\" ng-bind=\"title\"></div>\\n' +\n    '</div>\\n' +\n    '');\n}]);\n\nangular.module('template/organisation/select-organisation.tpl.html', []).run(['$templateCache', function($templateCache) {\n  'use strict';\n  $templateCache.put('template/organisation/select-organisation.tpl.html',\n    '<div class=\"dropdown\" dropdown auto-close=\"outsideClick\" is-open=\"isDropdownOpen\">\\n' +\n    '    <a href=\"\" class=\"dropdown-toggle form-control\" dropdown-toggle ng-disabled=\"ngDisabled\" ng-required=\"ngRequired\">\\n' +\n    '        {{ assignee.user || \\'Select element...\\' | translate}}\\n' +\n    '    </a>\\n' +\n    '\\n' +\n    '    <div class=\"dropdown-menu dropdown-menu-lg\">\\n' +\n    '        <div class=\"search-wrapper\">\\n' +\n    '            <input type=\"text\"\\n' +\n    '                   class=\"form-control search-input\"\\n' +\n    '                   placeholder=\"{{ \\'Search...\\' | translate}}\"\\n' +\n    '                   ng-model=\"search\"\\n' +\n    '                   ng-enter=\"false\"\\n' +\n    '                   tabindex=\"1\"\\n' +\n    '                   ng-change=\"searchTree()\">\\n' +\n    '        </div>\\n' +\n    '\\n' +\n    '        <input ng-model=\"assignee\" style=\"display: none;\" name=\"assignee\">\\n' +\n    '\\n' +\n    '        <div tree-view=\"tree\"\\n' +\n    '             tree-view-options=\"options\"\\n' +\n    '             focus-if=\"isDropdownOpen\"\\n' +\n    '             tabindex=\"2\"\\n' +\n    '             ng-model=\"assignee\"></div>\\n' +\n    '    </div>\\n' +\n    '</div>\\n' +\n    '');\n}]);\n\nangular.module('template/tabs/tabset.html', []).run(['$templateCache', function($templateCache) {\n  'use strict';\n  $templateCache.put('template/tabs/tabset.html',\n    '<div>\\n' +\n    '    <ul class=\"tab-nav\" ng-class=\"{\\'nav-stacked\\': vertical, \\'nav-justified\\': justified}\" ng-transclude></ul>\\n' +\n    '    <div class=\"tab-content\">\\n' +\n    '        <div class=\"tab-pane\"\\n' +\n    '             ng-repeat=\"tab in tabs\"\\n' +\n    '             ng-class=\"{active: tab.active}\"\\n' +\n    '             tab-content-transclude=\"tab\">\\n' +\n    '        </div>\\n' +\n    '    </div>\\n' +\n    '</div>\\n' +\n    '');\n}]);\n"
  ]
}